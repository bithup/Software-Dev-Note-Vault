# Architecture - DDD

> 2004 年著名建模专家 Eric Evans 发表了他最具影响力的书籍《Domain-Driven Design –Tackling Complexity in the Heart of Software》（领域驱动设计—软件核心复杂性应对之道），书中反复强调领域通用语言(Ubiquitous Language)的重要性，全面阐述了 DDD 战略设计到战术设计的方法论和实践





系统开发的问题：A 负责提出需求，B 负责需求分析，C 负责系统设计，D 负责代码实现，这样的流程很长，经手的人也很多，很容易导致信息丢失。

解决方法：需求分析和系统设计需要产品和开发共同参与，采用DDD模式，划分各个领域



什么是：测试驱动开发模式，ddd领域的核心逻辑测试，可以不依赖数据库吗？





## 领域

### 聚合与聚合根

- 聚合：多个对象的集合，对外是一个整体
- 聚合根：聚合中可代表整个业务操作的实体对象，通过它提供对外访问操作，它维护聚合内部的数据一致性，它是聚合中对象的管理者

### 实体对象与值对象

- 实体对象：具有唯一标识，能单独存在且可变化的对象
- 值对象：不能单独存在或在逻辑层面单独存在无意义，且不可变化的对象

### 贫血模型与充血模型

- 贫血模型：只有所有属性的get/set方式，以及少量简单的属性值转换，不包含任何业务逻辑，不关心对象持久化，只是用来做为数据对象的承载和传递的介质
- 此种模型下领域对象作用此领域相关行为，包含此领域相关的业务逻辑，同时也包含对领域对象的持久化操作。

## 分层架构

1. 基础设施层：数据库，缓存，MQ，远程接口等
2. 领域层：领域对象（聚合、实体、值对象）、领域服务接口
3. 应用层：应用服务，事件监听，消息监听，CQRS
4. 用户接口层：web api，DTO和DTO assemb，

## 六边形架构



> VO、DTO、DO、PO
>
> 1.VO（View Object），视图对象，用于展示层，它的作用是把某个指定页面（或组件）的所有数据封装起来，主要用来显示。
>
> 2.DTO（Data Transfer Object），数据传输对象，这个概念来源于J2EE的设计模式，原来的目的是为了EJB的分布式应用提供粗粒度的数据实体，以减少分布式调用的次数，从而提高分布式调用的性能和降低网络负载，但在这里，我泛指用于展示层与服务层之间的数据传输对象。
>
> 3.DO（Domain Object），领域对象，就是从现实世界中抽象出来的有形或无形的业务实体。
>
> 4.PO（PersistentObject），持久化对象，它跟持久层（通常是关系型数据库）的数据结构形成一一对应的映射关系，如果持久层是关系型数据库，那么，数据表中的每个字段（或若干个）就对应PO的一个（或若干个）属性。





[怼不过产品经理？因为你不懂DDD领域建模与架构设计 - 简书 (jianshu.com)](https://www.jianshu.com/p/f4b529e68657)







|--- adapter                     -- 适配器层 应用与外部应用交互适配

|      |--- controller           -- 控制器层，API中的接口的实现

|      |       |--- assembler    -- 装配器，DTO和领域模型的转换

|      |       |--- impl         -- 协议层中接口的实现

|      |--- repository           -- 仓储层

|      |       |--- assembler    -- 装配器，PO和领域模型的转换

|      |       |--- impl         -- 领域层中仓储接口的实现

|      |--- rpc                  -- RPC层,Domain层中port中依赖的外部的接口实现，调用远程RPC接口

|      |--- task                 -- 任务，主要是调度任务的适配器

|--- api                         -- 应用协议层 应用对外暴露的api接口

|--- boot                        -- 启动层 应用框架、驱动等

|      |--- aop                  -- 切面

|      |--- config               -- 配置

|      |--- Application          -- 启动类

|--- app                         -- 应用层

|      |--- cases                -- 应用服务

|--- domain                      -- 领域层

|      |--- model                -- 领域对象

|      |       |--- aggregate    -- 聚合

|      |       |--- entities     -- 实休

|      |       |--- vo           -- 值对象

|      |--- service              -- 域服务

|      |--- factory              -- 工厂，针对一些复杂的Object可以通过工厂来构建

|      |--- port                 -- 端口，即接口

|      |--- event                -- 领域事件

|      |--- exception            -- 异常封装

|      |--- ability              -- 领域能力

|      |--- extension            -- 扩展点

|      |       |--- impl        -- 扩展点实现

|--- query                       -- 查询层，封装读服务

|      |--- model                -- 查询模型

|      |--- service              -- 查询服务

|--- types                       -- 定义Domain Primitive
————————————————
版权声明：本文为CSDN博主「进朱者赤」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_30757161/article/details/116485388





[DDD在严选供应链复杂业务系统的落地实践 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/359029570)

> 
>
> **领域层**：处于系统最底层，包含业务聚合、实体、领域能力等；领域层需要的持久化，以及其他能力需要在领域层定义gateWay接口，在基础设施层或者应用层进行实现。
>
> **基础设施层**：依赖领域层，承接数据持久化等基础服务，实现了领域层定义的持久化gateWay接口，进行DO - PO数据转换，封装持久化细节等。
>
> **应用层**：依赖领域层和基础设施层，对接外围接口层适配器，提供查询和命令能力，并采用责任链模式进行逻辑编排。
>
> **接口层**：依赖应用层，提供外部服务的访问入口，包括但不限于HTTP、RPC等。
>
> **共享包**：工具类、异常类、服务中的DTO对象等，共享包的存在主要是为了解决领域层和应用层共享数据结构的问题。

![](https://pic3.zhimg.com/80/v2-519a4bb139c850453da4e5193c9fab1a_720w.jpg)



洋葱架构依赖关系：与数据库的交互全都放到基础设施层，其他层只定义接口，在基础设施层实现

![](https://pic1.zhimg.com/80/v2-7e2b24fd75c994e95564a7073ff03b6c_720w.jpg)

> 逻辑编排基本上还是事务脚本式的过程式编码，这意味着很容易走回到原本的状态，逻辑会越来越分散，代码会越来越臃肿，为此，我们引入了责任链的设计模式，来对这些逻辑编排进行结构上的优化。
>
> 
>
> 
>
> > 领域服务到底是什么？当领域中的某个操作或转换过程不是实体或值对象的职责时，此时便应该将该操作放在一个单独的接口，即领域服务。请确保该领域服务和通用语言是一致的；并且保证它是无状态的。



![](https://pic1.zhimg.com/80/v2-4c927d1470f5d7b12b4548dd5e7fe44c_720w.jpg)
