{
	"nodes":[
		{"id":"574db9e2bc62f76a","type":"file","file":"notes/1_Java SE/card/Java引用强度.md","x":435,"y":-615,"width":720,"height":95},
		{"id":"0e7de90e8e8f1045","type":"text","text":"# Number\n\n  \n\n## Java整数类型\n\n  \n\n### Integer\n\n  \n\n> `Integer a = 1000, b = 1000;`\n\n> `System.out.println(a == b);`\n\n> `Integer c = 100, d = 100;`\n\n> `System.out.println(c == d);`\n\n> 为什么 a == b为false，c == d为true\n\n  \n\nInteger类会缓存`-128~127`之间的值，c和d是同一个对象，而a和b是不同对象\n\n  \n  \n  \n\n## Java浮点数类型\n\n  \n\n### Double\n\n  \n\n#### double的底层实现原理\n\n  \n\n## Java精确计算\n\n  \n\nBigDecimal","x":435,"y":-440,"width":728,"height":789},
		{"id":"891667de663a0477","type":"file","file":"notes/1_Java SE/card/JVM类加载.md","x":-1320,"y":-840,"width":760,"height":940},
		{"id":"a9d1db24fd9dbe8f","type":"text","text":"## JVM调优\n\n根据实际情况，堆JVM的参数进行调整\n\n\n- 方法区的大小和堆空间一样，可以选择固定大小也可选择可扩展，方法区的大小决定了系统可以放多少个类，如果系统类太多，导致方法区溢出，虚拟机同样会抛出内存溢出错误\n- Java7 中我们通过`-XX:PermSize` 和 `-xx:MaxPermSize` 来设置永久代参数，Java8 之后，随着永久代的取消，这些参数也就随之失效了，改为通过`-XX:MetaspaceSize` 和 `-XX:MaxMetaspaceSize` 用来设置元空间参数\n\n---\n\n设置堆内存大小：通过 `-Xmx` 和 `-Xms` 控制\n- `-Xms` 用来表示堆的起始内存，等价于 `-XX:InitialHeapSize`\n- `-Xmx` 用来表示堆的最大内存，等价于 `-XX:MaxHeapSize`\n\n默认情况下新生代和老年代的比例是 1:2，可以通过 `–XX:NewRatio` 来配置\n- 新生代中的 **Eden**:**From Survivor**:**To Survivor** 的比例是 **8:1:1**，可以通过 `-XX:SurvivorRatio` 来配置\n\n---\n\n整个年轻代内存会在初始空间`-XX:G1NewSizePercent`(默认整堆5%)与最大空间(默认60%)之间动态变化，且由参数目标暂停时间`-XX:MaxGCPauseMillis`(默认200ms)、需要扩缩容的大小以`-XX:G1MaxNewSizePercent`及分区的已记忆集合(RSet)计算得到。当然，G1依然可以设置固定的年轻代大小(参数-XX:NewRatio、-Xmn)，但同时暂停目标将失去意义\n\n---\n### ZGC调优\n![[屏幕截图_8-8-2024_22152_pdai.tech.jpeg]]","x":-1340,"y":758,"width":780,"height":562},
		{"id":"2f120c8dea220350","type":"text","text":"## JVM内存模型\n\n![[Pasted image 20240808202405.png]]\n  \n  \n### 线程私有内存（方法栈、PC计数器）   \n\nPC计数器字节码操作指令的偏移地址，JVM字节码解释器通过偏移地址，找到字节码指令，将其解释成机器码交给操作系统执行。\n\n如果当前线程正在执行的是 Java 方法，程序计数器记录的是 JVM 字节码指令地址，如果是执行 native 方法，则是未指定值（undefined）\n\n\nJava线程中的方法栈\n  \n  - Java 方法有两种返回函数的方式，**一种是正常的函数返回，使用 return 指令，另一种是抛出异常，不管用哪种方式，都会导致栈帧被弹出**\n\n\n### 线程共享内存\n#### 方法区\n**运行时常量池**：Class 文件中除了有类的版本/字段/方法/接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将类在加载后进入方法区的运行时常量池中存放。运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的是 `String.intern()`方法。受方法区内存的限制，当常量池无法再申请到内存时会抛出 `OutOfMemoryErro`r 异常。\n\n---\n**类型信息**\nClass对象存放在方法去\n对每个加载的类型（类 class、接口 interface、枚举 enum、注解 annotation），JVM 必须在方法区中存储以下类型信息\n\n- 这个类型的完整有效名称（全名=包名.类名）\n- 这个类型直接父类的完整有效名（对于 interface或是 java.lang.Object，都没有父类）\n- 这个类型的修饰符（public，abstract，final 的某个子集）\n- 这个类型直接接口的一个有序列表\n\n**域（Field）信息**\n\n- JVM 必须在方法区中保存类型的所有域的相关信息以及域的声明顺序\n- 域的相关信息包括：域名称、域类型、域修饰符（public、private、protected、static、final、volatile、transient 的某个子集）\n\n**方法（Method）信息**\n\nJVM 必须保存所有方法的\n\n- 方法名称\n- 方法的返回类型\n- 方法参数的数量和类型\n- 方法的修饰符（public，private，protected，static，final，synchronized，native，abstract 的一个子集）\n- 方法的字符码（bytecodes）、操作数栈、局部变量表及大小（abstract 和 native 方法除外）\n- 异常表（abstract 和 native 方法除外）\n    - 每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引\n\n\n\n\n---\n\n#### 堆\n  \n在Java虚拟机（JVM）中，当你在堆上创建一个对象时，该对象不会包含方法的字节码。对象在堆上的存储结构主要包含以下部分：\n\n1. **对象头** (Header):\n    \n    - 包含对象的元数据，如哈希码、GC年龄、锁状态标志等。\n    - 如果对象属于某个类的实例，对象头还会包含指向该类的 `java.lang.Class` 对象的指针或引用。\n2. **实例数据** (Instance Data):\n    \n    - 包含对象的实例变量（字段）的值。\n    - 这些数据是对象特有的状态信息，每个对象的实例数据是独立的。\n3. **对齐填充** (Padding):\n    \n    - 为了使对象的大小符合JVM的内存对齐要求，可能会有一些填充字节。\n\n**方法字节码的位置**\n\n方法的字节码及其相关的元数据（包括方法签名、参数类型、返回类型等）存储在方法区（Method Area）中。方法区是JVM内存模型的一部分，它用于存储类的元数据信息，包括静态变量、常量池、字段和方法的描述等。\n\n\n","x":-442,"y":-840,"width":782,"height":1250},
		{"id":"c29d577cb1d3decc","type":"text","text":"## JVM GC\n[JVM 基础 - JVM 内存结构 ](https://pdai.tech/md/java/jvm/java-jvm-struct.html#%E5%9B%9B%E3%80%81%E5%A0%86%E5%86%85%E5%AD%98)\n\n![[屏幕截图_8-8-2024_21933_pdai.tech.jpeg]]  \n![[屏幕截图_8-8-2024_211032_pdai.tech.jpeg]]\n\n### MinorGC、MajorGC、FullGC\n\n- 部分收集：不是完整收集整个 Java 堆的垃圾收集。其中又分为：\n    - 新生代收集（Minor GC/Young GC）：只是新生代的垃圾收集\n    - 老年代收集（Major GC/Old GC）：只是老年代的垃圾收集\n        - 目前，只有 CMS GC 会有单独收集老年代的行为\n        - 很多时候 Major GC 会和 Full GC 混合使用，需要具体分辨是老年代回收还是整堆回收\n    - 混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集\n        - 目前只有 G1 GC 会有这种行为\n- 整堆收集（Full GC）：收集整个 Java 堆和方法区的垃圾。Full GC后，堆尺寸计算结果也会调整堆空间。\n\n\n> [!NOTE] 什么是GC Roots Tracing？\n> Contents\n\n## 垃圾回收器\n\n(1) Serial收集器：串行收集器是最古老，最稳定以及效率高的收集器，可能会产生较长的停顿，-XX:+UseSerialGC\n\n(2) ParNew收集器\n\nParNew收集器其实就是Serial收集器的多线程版本，新生代使用\"复制\"算法并行收集，老年代使用\"标记-压缩\"算法串行收集\n-XX:+UseParNewGC 指定收集器为ParNew收集器 -XX:ParallelGCThreads 限制线程数量\n(3) Parallel Scavenge 收集器\n(4) Parallel Old 收集器\n(5) CMS收集器\n(6) G1收集器\n(7) ZGC\n\n新生代和老年代可以使用不同的GC，根据新生代和老年代中对象的不同特点，选择不同算法的收集器\n\n不同场景选择不同的收集器\n- 要求响应时间短，ZGC\n- 要求不影响吞吐量，设置少一点的GC线程数\n- 内存比较小，不能使用复制算法的GC\n- 大型应用：G1\n\n\n\n### G1\n标记-复制垃圾回收器\n回收得到的空间是连续的\n每个region可以是年轻代、老年代的一个。内存的回收是以region作为基本单位的\n可设置垃圾回收的时间\n目标参数-XX:GCTimeRatio即为GC与应用的耗费时间比，G1默认为9，而CMS默认为99，因为CMS的设计原则是耗费在GC上的时间尽可能的少。\n[GC - Java 垃圾回收器之G1详解 | Java 全栈知识体系 (pdai.tech)](https://pdai.tech/md/java/jvm/java-jvm-gc-g1.html)\n\n> 分代垃圾收集可以将关注点集中在最近被分配的对象上，而无需整堆扫描，避免长命对象的拷贝，同时独立收集有助于降低响应时间。虽然分区使得内存分配不再要求紧凑的内存空间，但G1依然使用了分代的思想。与其他垃圾收集器类似，G1将内存在逻辑上划分为年轻代和老年代，其中年轻代又划分为Eden空间和Survivor空间。但年轻代空间并不是固定不变的，当现有年轻代分区占满时，JVM会分配新的空闲分区加入到年轻代空间。\n\n因此，**G1停顿时间的瓶颈主要是标记-复制中的转移阶段STW**\n\nG1的Young GC和CMS的Young GC，其标记-复制全过程STW\n![[Pasted image 20240808222135.png]]\nG1收集器将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。\n\n---\n\n### ZGC\nZGC（The Z Garbage Collector）是JDK 11中推出的一款低延迟垃圾回收器, 是JDK 11+ 最为重要的更新之一，适用于**大内存低延迟**服务的内存管理和回收。\n- 停顿时间不超过10ms；\n- 停顿时间不会随着堆的大小，或者活跃对象的大小而增加（对程序吞吐量影响小于15%）；\n- 支持8MB~4TB级别的堆（未来支持16TB）\n\n> ZGC通过着色指针和读屏障技术，解决了转移过程中准确访问对象的问题，实现了并发转移。大致原理描述如下：并发转移中“并发”意味着GC线程在转移对象的过程中，应用线程也在不停地访问对象。假设对象发生转移，但对象地址未及时更新，那么应用线程可能访问到旧地址，从而造成错误。而在ZGC中，应用线程访问对象将触发“读屏障”，如果发现对象被移动了，那么“读屏障”会把读出来的指针更新到对象的新地址上，这样应用线程始终访问的都是对象的新地址。那么，JVM是如何判断对象被移动过呢？就是利用对象引用的地址，即着色指针。下面介绍着色指针和读屏障技术细节\n\n---\n\n著作权归@pdai所有 原文链接：https://pdai.tech/md/java/jvm/java-jvm-gc-zgc.html\n\n---\n\n\n### CMS GC\n\n**CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器**。这是因为CMS收集器工作时，GC工作线程与用户线程可以`并发`执行，以此来达到降低收集停顿时间的目的。\n\nCMS收集器仅作用于**老年代**的收集\n\n\n> [!NOTE] CMS为什么不作用域新生代\n> CMS收集器之所以能够做到并发，根本原因在于**采用基于“标记-清除”的算法并对算法过程进行了细粒度的分解**。前面篇章介绍过标记-清除算法将产生大量的内存碎片这对新生代来说是难以接受的，因此新生代的收集器并未提供CMS版本。\n\n\n\nG1与CMS的特征对比如下：\n\n|特征|G1|CMS|\n|---|---|---|\n|并发和分代|是|是|\n|最大化释放堆内存|是|否|\n|低延时|是|是|\n|吞吐量|高|低|\n|压实|是|否|\n|可预测性|强|弱|\n|新生代和老年代的物理隔离|否|是|\n## GC算法\n- 标记-清除\n清楚垃圾对象，会造成大量碎片空间\n\n- 标记-复制算法\n将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉\n好处是保持内存连续性，算法简单，缺点是需要复制，始终有一半内存是空闲的\n\n- 标记-压缩\n和标记-复制类似，但是不需要有两块大小一样的内存，只需要把存活对象向一端移动，整理出连续的内存空间\n\n- 分代收集\n  \n  \n  \n\n## GC日志\n\n[求求你了，配个GC日志呗，不然咋分析故障原因 (qq.com)](https://mp.weixin.qq.com/s/WLYWHq621C4L6NaOlhhrpA)","x":-1340,"y":202,"width":760,"height":516},
		{"id":"2c7e0f676077ff71","type":"text","text":"## Class文件字节码","x":-442,"y":410,"width":540,"height":50},
		{"id":"853e1db878cc34a5","type":"text","text":"符号引用&直接引用","x":-1937,"y":-840,"width":477,"height":531},
		{"id":"f8b89ab0fd0bd926","type":"file","file":"resources/unsorted/Pasted image 20240808202405.png","x":-1860,"y":-178,"width":367,"height":400},
		{"id":"e8ffaa344735a8e4","x":-1855,"y":480,"width":255,"height":238,"type":"text","text":"新生代和老年代是分代收集中的概念，在物理内存中，可以是连续的，也可以不连续（比如G1）"},
		{"id":"6d81d83a6410e046","x":-1855,"y":753,"width":255,"height":167,"type":"text","text":"一个收集器，可以同时使用分代收集算法和标记-复制算法"}
	],
	"edges":[]
}