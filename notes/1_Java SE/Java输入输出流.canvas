{
	"nodes":[
		{"id":"80de25ef90991498","type":"group","x":-560,"y":-540,"width":3140,"height":1560,"label":"文件IO与网络IO"},
		{"id":"5cfdb1112055420c","type":"group","x":-560,"y":-4140,"width":2100,"height":1800,"label":"BIO"},
		{"id":"fd7d96487fcfcc9c","type":"group","x":-560,"y":-2260,"width":2100,"height":1640,"label":"NIO"},
		{"id":"891cb2f033f41565","type":"text","text":"java中IO多路复用的使用场景\nNIO的使用场景\n\n1. 连接数特别多，发送的数据少，比如聊天服务器","x":3200,"y":-153,"width":250,"height":293},
		{"id":"4089a6c73d806c74","type":"text","text":"磁盘文件2","x":55,"y":-468,"width":250,"height":60},
		{"id":"1b9d638935d7c4c3","type":"text","text":"服务器内存","x":-225,"y":-225,"width":250,"height":50},
		{"id":"0d12b0c0af46b928","type":"text","text":"网络客户端 1","x":-520,"y":40,"width":250,"height":60},
		{"id":"917c0feb62428fc5","type":"text","text":"网络客户端 2","x":55,"y":40,"width":250,"height":60},
		{"id":"520885a35eb0d184","type":"text","text":"## Channel\n\n1. Java提供的四种channel(抽象类)\n\t- `FileChannel`：用于读取、写入、映射和操作文件的通道\n\t- `DatagramChannel`：通过 UDP 读写网络中的数据通道\n\t- `SocketChannel`&`ServerSocketChannel`：通过 TCP 读写网络中的数据\n2. Channel可分为两类\n\t- `SelectableChannel`(网络)\n\t- `FileChannel`(文件)\n3. 获取通道的方式\n\t- 通过`FileIputStream`、`FileOutputStream`、`RandomAccessFile`类对象的`getChannel()`方法获取；\n\t- 通过`DatagramSocket`、`Socket`、`ServerSocket`类对象的`getChannel()`方法获取；\n\t- 通过`Files`类的`newByteChannel()`方法获取；\n\t- 通过`FileChannel`、`SocketChannel`、`ServerSocketChannel`、`DatagramChannel`类的`open()`方法获取；\n\n> 将共享内存和磁盘文件建立联系的是文件通道类：`FileChannel`。\n> 该类的加入是JDK为了统一对外部设备（文件、网络接口等）的访问方法，并且加强了多线程对同一文件进行存取的安全性。\n> `FileChannel`提供了`map()`方法把文件映射到虚拟内存，通常情况可以映射整个文件，如果文件比较大，可以进行分段映射。\n\n### channel映射文件到直接内存\n```java\n// 使用FileChannel.map方法，将磁盘文件映射到直接内存\nRandomAccessFile raf = new RandomAccessFile(\"a.txt\", \"rw\");  \nFileChannel channel = raf.getChannel(); \n// 调用map方法后 buffer中就有数据\nMappedByteBuffer buffer = channel.map(FileChannel.MapMode.READ_ONLY, 0, raf.length());  \nbyte b = buffer.get();  \nSystem.out.println(b);\n```\n\n### channel读写buffer\n```java\n//将buffer中的数据通过channel写入socket内核缓冲区\n//可写入单个buffer或buffer数组\nsocketChannel.write(buffer);\n//将file内核缓冲去的数据通过channel读取到buffer\nfileChannel.read(buffer)\n```\n\n### channel零拷贝\n```java\nFile file = new File(\"test.txt\");  \nRandomAccessFile raf = new RandomAccessFile(file, \"rw\");  \nFileChannel fileChannel = raf.getChannel();  \nSocketChannel socketChannel = SocketChannel.open(new InetSocketAddress(\"192.168.0.1\", 1234));  \n// 将fileChannel中的数据传输到socketChannel  \nfileChannel.transferTo(0, fileChannel.size(), socketChannel);  \n//或者将socketChannel中的数据传输到fileChannel  \nfileChannel.transferFrom(socketChannel, 0, fileChannel.size());\n```\n\n\n> [!NOTE] 对channel的理解\n> channel是内存连接文件或者socket的通道\n> channel的read方法是将文件或socket数据读取到buffer，数据是从外围设备流向内存\n> channel的write方法是将buffer中的数据写入到文件或socket，数据是从内存流向外围设备\n> \n\n### SocketChannel和FileChannel对比\n- 实现的接口有差别\n\t- [[SocketChannel-diagram.png|SocketChaneel]]&[[FileChannel-diagram.png | FileChannel]]\n- 只有`FileChannel`有`transferTo()`、`transferFrom()`、`map()`等方法，`SocketChannel`没有。\n- 只有SocketChannel和ServerSocketChannel可设置阻塞/非阻塞，FileChannel不可以。\n\n\n\n","x":-507,"y":-1492,"width":887,"height":812},
		{"id":"5ef578a84eb710da","type":"text","text":"磁盘文件1","x":-520,"y":-468,"width":250,"height":60},
		{"id":"2b7ba440b7d9bc23","type":"file","file":"resources/unsorted/NioEventLoopGroup.svg","x":-1234,"y":-94,"width":226,"height":399},
		{"id":"780a35a7413b0d4d","type":"text","text":"## Buffer\n\nJava为七种基本数据类型（除Boolean）都提供对应的缓冲区类，都继承了Buffer类\n\n> [!NOTE] 内存映射与直接缓冲区\n> 以往BIO模式下，要读取一个本地磁盘文件，需要先将磁盘数据读取到操作系统内核缓冲区，然后复制到用户缓冲区。内存映射是指将用户缓冲区视为内核缓冲区，直接读取磁盘数据到用户缓冲区。经过内存映射的缓冲区叫直接缓冲区，一般说的缓冲区就是非直接缓冲区。直接缓冲区的优点是避免数据从内核缓冲区复制到用户缓冲区；直接缓冲区是在jvm内存外开辟的内存，开销大。\n\n\n> [!NOTE] socket缓冲区和磁盘文件缓冲区\n> 磁盘文件数据存储在磁盘上，程序要使用磁盘文件，需要先将磁盘文件拷贝到内存；socket数据可看作存储在网卡上的文件，同样应用程序要读写socket数据，需要先将网卡中的数据拷贝到内存\n\n\n> [!NOTE] linux系统的mmap与sendfile\n> mmap（内存映射），可以减少了一次数据从内核空间到用户空间的拷贝。sendfile则可以减少一次数据从内核空间到内核空间的拷贝。假设要将一个磁盘文件，通过网络发送出去，在只使用mmap的情况下，数据还需要从文件内核缓冲区复制到socket内核缓冲区，使用sendfile就可以减少一次内核空间中的数据拷贝。\n\n\nBuffer中的概念\n- 容量（capacity）：缓冲区容量，不能为负，不可修改\n- 限制（limit）：第一个不可读取的数据的索引\n- 位置（position）：下一个要读取或写入的数据的索引\n- 标记（mark）：标记一个索引\n- 重置（reset）：恢复到之前标记的索引\n##### ByteBuffer\n\nByteBuffer子类\n- ByteBuffer\n\t- HeapByteBuffer\n\t- MappedByteBuffer\n\t\t- DirectByteBuffer\n\nByteBuffer内存分配方法\n```java\npublic abstract class ByteBuffer extends Buffer implements Comparable<ByteBuffer> {\n    final byte[] hb; \n    final int offset;\n    boolean isReadOnly;\n    // 分配非直接缓冲区（堆缓冲区）\n    public static ByteBuffer allocate(int capacity) {\n        if (capacity < 0)\n            throw new IllegalArgumentException();\n        // class HeapByteBuffer extends ByteBuffer\n        return new HeapByteBuffer(capacity, capacity);\n    }\n    // 分配直接缓冲区\n    public static ByteBuffer allocateDirect(int capacity) {\n        return new DirectByteBuffer(capacity);\n    }\n}\n```\n\n\n\nBuffer读写数据的方法，给定index的读写不会改变position位置\n\n- `get()`：\n- `get(byte[] dst)`：\n- `get(int index)`：\n- `put(byte b)`：\n- `put(byte b)`：\n- `put(int index, byte b)`：\n\nBuffer其他操作\n\n- flip方法：反转读写模式\n- rewind方法：将position设回0\n- clear/compact方法：清空所有/已读数据\n\n","x":-518,"y":-2194,"width":898,"height":634},
		{"id":"b0a0e7897ab1a028","type":"text","text":"## 流的包装(转换、缓冲)\n在创建流对象的时，将一个流传入另一个流\n使用装饰设计模式，实现流的转换、缓冲等功能\n\nInputStream -> BufferedInputStream\n\nInputStream -> InputStreamReader -> BufferedReader\n\n\nInputStreamReader时Reader的子类，接收一个InputSream对象\n\n\n\n\n\n","x":-479,"y":-3080,"width":859,"height":640},
		{"id":"b4a4e1a689068af4","type":"text","text":"## InputStream\n\n### 继承关系\n实现接口\n```java\npublic interface Closeable extends AutoCloseable {}\npublic abstract class InputStream implements Closeable {}\n```\n\n常见子类\n- ObjectInputStream\n- StringBufferInputStream\n- FilterInputStream\n\t- DataInputStream\n\t- CheckedInputStream\n\t- BufferedInputStream\n\t- PushbackInputStream\n\t- LineNumberInputStream\n- ByteArrayInputStream\n- PipedInputStream\n- SequenceInputStream\n- FileInputStream\n\n\n- `ByteArrayInputStream`：字节数组输入流\n- `ObjectInputStream`：引用类型输入处理流（对象反序列化）\n- `PipedInputStream`\n- `StringBufferInputStream`：已过时，建议使用StringReader\n- `FilterInputStream`：\n  - `BufferedInputStream`：字节输入缓冲流\n  - `DataInputStream`：数据类型输入流（基本类型+String）\n- `SequenceInputStream`\n- `FileInputStream`：文件输入流\n\n\n### 方法分析\n抽象方法\npublic abstract int read() throws IOException;\n读取一个字节，返回一个int类型，取值范围[-1, 255]\n一个字节表示无符号非负整数的范围时[0, 255]\n返回负1表示没有数据可读取了。\n读取数据时方法会阻塞\n其他方法都是将数据读取到数组中，通过for循环调用read()方法实现\n\n\n- `public abstract int read() throws IOException;`，读取一个字节的数据，返回int类型整数，返回值取值范围为-1~255，-1是文件读取结束的标识。使用-1作为文件结束的标识的原因是，read()方法将读取的一个字节的数据当做无符号整数处理，范围是0~255；\n- `public int read(byte b[])`，读取多个字节的数据到给定的byte数组，每次读取都需要将int强转为byte；如果数组长度为0，返回0，如果读到文件尾返回-1，如果读取到数组长度个字节或中途读取到文件尾，返回已读取到字节长度。\n\n\n> [!faq] 文件读取时，在循环中每次读取一个字节，性能不会差吗？\n> FileInputStream中读取数据的read方法是jvm本地方法，基于块的读取不是循环调用单字节读取\n> \n\n\n","x":-480,"y":-4100,"width":860,"height":960},
		{"id":"441447c057d68c1c","type":"text","text":"## Reader\n### 继承关系\n实现接口\n```java\npublic abstract class Reader implements Readable, Closeable {}\npublic class InputStreamReader extends Reader {} // 转换流，接收字节流转换成字符流\n```\n\n常见子类\n- `BufferedReader`：缓冲字符流，默认缓冲区大小char[8192]\n\t- LineNumberReader\n- `InputStreamReader`：转换流，可指定编码格式\n  - FileReader：继承了InputStreamReader，这两个类基本没有区别，FileReader使用默认编码格式\n- `BufferedReader`：流有readLine方法\n- PipedReader\n- CharArrayReader\n- LineReader\n- FilterReader\n\t- PushbackReader\n- StringReader\n\n### 方法分析\n\n- `abstract public int read(char cbuf[], int off, int len)`：读取多个字符到给定的字符数组，返回读取到的字符数，-1是文件结束标识；\n- `public int read()`：非抽象方法，调用上面的抽象方法，读取一个字符，返回的是读取到的字符，取值范围是char类型的取值范围0x0000~0xFFFF或-1；\n","x":560,"y":-4100,"width":880,"height":960},
		{"id":"ca7b6286ef07e28e","type":"text","text":"## BIO常见代码示例\n\n使用字节输入流读写磁盘文件\n\n```java\npublic class IOTest {\n    public static void main(String[] args) throws IOException {\n        File inFile = new File(\"\");\n        File outFile = new File(\"\");\n        FileInputStream fis = new FileInputStream(inFile);\n        FileOutputStream fos = new FileOutputStream(outFile);\n        int len;\n        // 单字节读写，fis.read()返回的是读取到的字节数据\n        while ((len = fis.read()) != -1) {\n            fos.write(len)\n        }\n        // 自定义缓冲区\n        byte[] buffer = new byte[1024*10];\n        // fis.read(buffer)返回的是获取到的字节数\n        while ((len = fis.read(buffer)) != -1) {\n            fos.write(buffer, 0, len);\n        }\n        // 使用缓冲流，和默认缓冲区大小\n        BufferedInputStream bis = new BufferedInputStream(fis, 8192);\n        BufferedOutputStream bos = new BufferedOutputStream(fos);\n        while ((len = bis.read()) != -1) {\n            bos.write(len);\n        }\n    }\n}\n```\n\n\n使用转换流，从命令行字节输入流System.in中读取命令行字符串\n\n```java\npublic class IOTest {\n    public static void main(String[] args) {\n        String s = null;\n        Integer i = null;\n        //\n        InputStreamReader isr = new InputStreamReader(System.in);\n        BufferedReader br = new BufferedReader(isr);\n        try {\n            s = br.readLine();\n            System.out.println(s);\n            br.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        Scanner scanner = new Scanner(System.in);\n        s = scanner.nextLine();\n        i = scanner.nextInt();\n    }\n}\n```\n\n使用字符输入流读取字符文件\n\n```java\npublic class IOTest {\n    public static void main(String[] args) throws IOException {\n        File inFile = new File(\"\");\n        File outFile = new File(\"\");\n        FileInputStream fis = new FileInputStream(inFile);\n        FileOutputStream fos = new FileOutputStream(outFile);\n\n        InputStreamReader isr = new InputStreamReader(fis);\n        // 转换流也能接收缓冲字节流\n        //BufferedInputStream bis = new BufferedInputStream(fis);\n        //InputStreamReader isr = new InputStreamReader(bis);\n        OutputStreamWriter osw = new OutputStreamWriter(fos);\n\n        // FileReader继承InputStreamReader，封装了转换流，方便使用\n        FileReader fr = new FileReader(inFile);\n        // 字符缓冲流\n        BufferedReader br = new BufferedReader(fr);\n        String temp = null;\n        while ((temp = br.readLine()) != null) {\n            System.out.println(temp);\n        }\n    }\n}\n```\n\n文件和文件夹的拷贝\n\n```java\nimport java.io.*;\n\npublic class Main {\n\n    public static void main(String[] args) throws Exception {\n\t\t// write your code here\n        String s = \"/Users/bithup/Desktop/test\";\n        String d = \"/Users/bithup/Desktop/test1\";\n        copyDir(s, d);\n    }\n\n    public static void copyFile(String srcPath, String destPath) {\n        BufferedInputStream bis = null;\n        BufferedOutputStream bos = null;\n        byte[] buf = new byte[1024];\n        try {\n            bis = new BufferedInputStream(new FileInputStream(srcPath));\n            bos = new BufferedOutputStream(new FileOutputStream(destPath));\n            int len;\n            while ((len = bis.read(buf)) > -1) {\n                bos.write(buf, 0, len);\n            }\n            bos.flush();\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                bis.close();\n                bos.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public static void copyDir(String srcPath, String destPath) throws Exception {\n        File src = new File(srcPath);\n        File dest = new File(destPath);\n        if (!src.exists() || !src.isDirectory()) {\n            throw new IllegalArgumentException(\"源文件不存在或不是文件夹！\");\n        }\n        if (!dest.exists()) {\n            dest.mkdir();\n        }\n        File[] files = src.listFiles();\n        for (File f : files) {\n            if (f.isFile()) {\n                copyFile(srcPath+File.separator+f.getName(), destPath+File.separator+f.getName());\n            } else if (f.isDirectory()) {\n                copyDir(srcPath+File.separator+f.getName(), destPath+File.separator+f.getName());\n            }\n        }\n    }\n}\n```\n\n\n\n\n\n","x":560,"y":-3080,"width":880,"height":640},
		{"id":"bd97b01593124b22","type":"text","text":"## Selector\nSocketChannel和ServerSocketChannel可设置阻塞/非阻塞模式，默认是阻塞模式，当使用非阻塞模式时，就需要使用Selector和SelectionKey\n\n步骤：\n1. 创建ServerSocketChannel实例\n2. 开启Selector，单实例的\n3. 为serverSocketChannel注册accept事件\n4. 进入轮询while(true)\n\t1. 获取可操作的Key集合\n\t2. 对可操作的key集合遍历，处理对应事件\n\n创建非阻塞模式代码示例\n```java\n@Slf4j  \npublic class NonBlockingServer {  \n    private final static int MESSAGE_LENGTH = 1024 * 1024 * 100;  \n  \n    public static void main(String[] args) throws Exception {  \n        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();  \n        serverSocketChannel.configureBlocking(false);  \n        serverSocketChannel.bind(new InetSocketAddress(\"127.0.0.1\", 8080), 50);  \n        Selector selector = Selector.open();  \n        SelectionKey serverSocketKey = serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);  \n        while (true) {  \n            int count = selector.select();  \n            log.info(\"select event count:\" + count);  \n            Set<SelectionKey> selectionKeys = selector.selectedKeys();  \n            Iterator<SelectionKey> iterator = selectionKeys.iterator();  \n            while (iterator.hasNext()) {  \n                SelectionKey selectionKey = iterator.next();  \n                // 有客户端请求建立连接  \n                if (selectionKey.isAcceptable()) {  \n                    handleAccept(selectionKey);  \n                }  \n                // 有客户端发送数据  \n                else if (selectionKey.isReadable()) {  \n                    handleRead(selectionKey);  \n                }  \n                // 可以向客户端发送数据  \n                else if (selectionKey.isWritable()) {  \n                    handleWrite(selectionKey);  \n                }  \n                iterator.remove();  \n            }  \n        }  \n    }  \n  \n    private static void handleAccept(SelectionKey selectionKey) throws IOException {  \n        ServerSocketChannel serverSocketChannel = (ServerSocketChannel) selectionKey.channel();  \n        SocketChannel socketChannel = serverSocketChannel.accept();  \n        if (Objects.nonNull(socketChannel)) {  \n            log.info(\"receive connection from client. client:{}\", socketChannel.getRemoteAddress());  \n            // 设置客户端Channel为非阻塞模式，否则在执行socketChannel.read()时会阻塞  \n            socketChannel.configureBlocking(false);  \n            Selector selector = selectionKey.selector();  \n            socketChannel.register(selector, SelectionKey.OP_READ);  \n        }  \n    }  \n  \n    private static void handleRead(SelectionKey selectionKey) throws IOException {  \n        SocketChannel socketChannel = (SocketChannel) selectionKey.channel();  \n        ByteBuffer readBuffer = ByteBuffer.allocate(MESSAGE_LENGTH);  \n        int length = 0;  \n        while (length < MESSAGE_LENGTH) {  \n            length += socketChannel.read(readBuffer);  \n        }  \n        log.info(\"receive message from client. client:{} message length:{}\", socketChannel.getRemoteAddress(), readBuffer.position());  \n  \n        ByteBuffer writeBuffer = ByteBuffer.allocate(readBuffer.position());  \n        readBuffer.flip();  \n        writeBuffer.put(readBuffer);  \n        // 读完数据后，为 SelectionKey 注册可写事件  \n        if (!isInterest(selectionKey, SelectionKey.OP_WRITE)) {  \n            selectionKey.interestOps(selectionKey.interestOps() + SelectionKey.OP_WRITE);  \n        }  \n        writeBuffer.flip();  \n        selectionKey.attach(writeBuffer);  \n    }  \n  \n    // 服务端可能是为每个Channel维护一块缓冲区，当向某个Channel写数据时缓冲区满了，还可以向其他Channel写数据  \n    private static void handleWrite(SelectionKey selectionKey) throws IOException {  \n        SocketChannel socketChannel = (SocketChannel) selectionKey.channel();  \n        ByteBuffer writeBuffer = (ByteBuffer) selectionKey.attachment();  \n        int writeLength = socketChannel.write(writeBuffer);  \n        log.info(\"send message to client. client:{} message length:{}\", socketChannel.getRemoteAddress(), writeLength);  \n        if (!writeBuffer.hasRemaining()) {  \n            // 写完数据后，要把写事件取消，否则当写缓冲区有剩余空间时，会一直触发写事件  \n            selectionKey.interestOps(selectionKey.interestOps() - SelectionKey.OP_WRITE);  \n            // socketChannel.shutdownOutput(); // channel调用shutdownOutput()后，会停止触发写事件  \n        }  \n    }  \n  \n    // 判断 SelectionKey 对某个事件是否感兴趣  \n    private static boolean isInterest(SelectionKey selectionKey, int event) {  \n        int interestSet = selectionKey.interestOps();  \n        boolean isInterest = (interestSet & event) == event;  \n        return isInterest;  \n    }  \n}\n```\n\n\n\n> [!faq] 为什么不在给SocketChannel注册读事件的时候一起注册写事件？\n> 注册写事件是为了检测写缓冲区是否有空间，如果同时注册读和写事件，还未读取客户端数据就已经可写，不符合逻辑。\n\n\n> [!faq] 为什么不在处理完读事件后直接写数据而注册写事件？\n> 如果在处理完读事件后直接写数据，如果数据量大，写缓冲区已满，就会阻塞当前线程。\n\n\n","x":560,"y":-2154,"width":880,"height":594},
		{"id":"0c254bd520b936ac","type":"file","file":"notes/5_Linux Server/linux io模型.md","x":1700,"y":-3740,"width":985,"height":693},
		{"id":"469c7cec7d783b96","type":"text","text":"## SelectionKey\n\nSelectionKey的作用就是来获取事件的状态\nSelectionKey对象获取：\n- selector.selectedKeys()\n- channel.register()\n\n四种事件状态标识和判断事件是否就绪的方法\n\n```java\npublic static final int OP_READ = 1 << 0;\npublic static final int OP_WRITE = 1 << 2;\npublic static final int OP_CONNECT = 1 << 3;\npublic static final int OP_ACCEPT = 1 << 4;\npublic final boolean isReadable() { return (readyOps() & OP_READ) != 0;}\npublic final boolean isWritable() { return (readyOps() & OP_WRITE) != 0;}\npublic final boolean isConnectable() { return (readyOps() & OP_CONNECT) != 0;}\npublic final boolean isAcceptable() { return (readyOps() & OP_ACCEPT) != 0;}\n```\n\n事件状态标识可以使用加减号，与或非进行运算\n```java\nsk.interestOps(sk.interestOps() | SelectionKey.OP_WRITE);\n```\nselectionKey的附加对象\n可以在register时附加\n或者使用\nselectionKey.attach(\"msg\")\n获取已经附加的对象\nselectionKey.attachment()\n清空附加的对象\nselectionKey.attach(null)\n如果附加的对象不再使用，一定要人为清除，因为垃圾回收器不会回收该对象，若不清除的话会成内存泄漏。","x":560,"y":-1460,"width":880,"height":600},
		{"id":"01d980a7d5a2696b","type":"text","text":"## 异步IO\nNIO 1.0（多路复用IO）不支持文件的异步读写，jdk1.7升级NIO 2.0，提供AIO库支持文件异步操作，AIO才是基于事件驱动的异步IO；AIO是对NIO的补充，提供`Asynchronous`相关类；Java 异步 IO 提供了两种使用方式，分别是返回`Future`实例和使用回调函数`java.nio.channels.CompletionHandler`。\n\n参考[深入理解Java AIO)](https://www.cnblogs.com/fatmanhappycode/p/12388683.html)","x":560,"y":-840,"width":880,"height":200},
		{"id":"35b1fa872aff6340","type":"text","text":"## Java Socket编程\n### BIO Socket编程\nsocket对象中包含IP&端口号，标识网络中的一个通信目标\n```java\n// 创建一个socket，连接服务器\nSocket s = new Socket(\"192.168.1.2\", 8080);\n```\n在客户端/服务器模式下，一个服务器可接收多个客户端请求，服务器端使用ServerSocket专门接收请求，接收一个请求，创建一个socket对象\n```java\n// 监听端口，等待客户端请求\nServerSocket serverSocket = new ServerSocket(8888);  \n// 接收到客户端请求，创建对应客户端的socket\nSocket socket = serverSocket.accept();\n```\n通过socket对象可以获取输入流/输出流\n```java\n// 通过socket获取字节输入/输出流，转换成字符流进行读写\nInputStreamReader in = new InputStreamReader(socket.getInputStream());\nOutputStreamWriter op = new OutputStreamWriter(socket.getOutputStream());\nop.write(\"QUERY TIME ORDER\");\nop.close();\nsocket.close();\n```\n\n### NIO Socket编程\n\n> [!NOTE] 高并发场景使用IO多路复用\n> 在常见的web应用中，服务器端接收一个请求，创建一个socket，相应的创建一个线程去处理socket的读写，socket和线程不是1:1。而在高并发场景下，创建大量的线程会消耗大量资源，导致内存耗尽、性能下降等问题；IO多路复用技术是一种解决方案，使用一个线程或线程池去处理大批量的socket读写，socket和线程的比例时n:m。\n\n\n\nNIO中与ServerSocket和Socket对应的有SocketChannel和ServerSocketChannel\n\n服务器获取SocketChannel\n```java\nServerSocket serverSocket = new ServerSocket(8888);  \nSocket socket = serverSocket.accept();  \nSocketChannel socketChannel = socket.getChannel();\n```\n或\n```java\nServerSocketChannel ssc = ServerSocketChannel.open();  \nssc.configureBlocking(false);  \nssc.socket().bind(new InetSocketAddress(\"127.0.0.1\", 8080));  \nssc.socket().setReuseAddress(true);  \nSocketChannel sc = ssc.accept();\n```\n客户端创建SocketChannel\n```java\n// 方式 1\nSocketChannel socketChannel = SocketChannel.open(new InetSocketAddress(\"www.baidu.com\", 80));\n// 方式 2\nSocketChannel socketChannel = SocketChannel.open();\nsocketChannel.connect(new InetSocketAddress(\"www.baidu.com\", 80));\n```","x":1600,"y":-500,"width":940,"height":985},
		{"id":"22575ad653376677","type":"text","text":"## Java文件读写\n\n### BIO文件读写\n\n### NIO文件读写\n\n\n```java\nimport java.io.*;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.charset.Charset;\n \npublic class Test {\n    public static void main(String[] args) {\n        File file = new File(\"D:\\\\Test04.java\");\n        try(\n                FileInputStream fileInputStream = new FileInputStream(file);\n                FileOutputStream fileOutputStream = new FileOutputStream(\"D:\\\\Test04.txt\");\n                FileChannel inChannel =fileInputStream.getChannel();\n                FileChannel outChannel = fileOutputStream.getChannel();\n                ) {\n            MappedByteBuffer buffer = inChannel.map(FileChannel.MapMode.READ_ONLY, 0, file.length());\n            //写出操作\n            outChannel.write(buffer);\n            //翻转，进行读取操作\n            buffer.flip();\n            //解码\n            Charset charset =Charset.defaultCharset();\n            System.out.println(charset.decode(buffer));\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n \n    }\n}\n```\n\n","x":600,"y":-498,"width":920,"height":983},
		{"id":"0ffb02db1680c29a","type":"file","file":"notes/其他/Netty.md","x":-1880,"y":-2486,"width":1140,"height":1400}
	],
	"edges":[
		{"id":"506b760b598db68a","fromNode":"5ef578a84eb710da","fromSide":"bottom","toNode":"1b9d638935d7c4c3","toSide":"top"},
		{"id":"ed12210add40aa88","fromNode":"1b9d638935d7c4c3","fromSide":"bottom","toNode":"0d12b0c0af46b928","toSide":"top"},
		{"id":"eede9dea002f086b","fromNode":"917c0feb62428fc5","fromSide":"top","toNode":"1b9d638935d7c4c3","toSide":"bottom"},
		{"id":"ee93712670b50aee","fromNode":"1b9d638935d7c4c3","fromSide":"top","toNode":"4089a6c73d806c74","toSide":"bottom"}
	]
}