{
	"nodes":[
		{"id":"84c2854e14580215","type":"group","x":-3920,"y":4520,"width":2440,"height":3640,"label":"Java线程池"},
		{"id":"f52ffb5a4da2c7b1","type":"group","x":-5800,"y":940,"width":4320,"height":1620,"label":"Java线程的生命周期与状态流转"},
		{"id":"dcca83a4b2d3e362","type":"group","x":-3940,"y":2720,"width":2460,"height":1680,"label":"Java线程同步方法"},
		{"id":"73cc53900f59e3ec","type":"group","x":-5800,"y":4520,"width":1600,"height":1880,"label":"Java中的锁"},
		{"id":"d2205b61591a1f19","type":"group","x":-5800,"y":2720,"width":1500,"height":1680,"label":"并发编程概念"},
		{"id":"a804f3cbd3bfc083","x":-3075,"y":4590,"width":1515,"height":1190,"type":"group","label":"线程池的使用"},
		{"id":"a0c2473f17056922","type":"group","x":-3020,"y":0,"width":1540,"height":840,"label":"Thread类源码分析"},
		{"id":"beb3ae3b2b6e2bcc","x":-3420,"y":5880,"width":1460,"height":640,"type":"group","label":"任务提交与任务结果获取"},
		{"id":"829eb6903512b4d6","type":"group","x":-5200,"y":-160,"width":834,"height":830,"label":"Java创建线程方式"},
		{"id":"e7fad8ab98a19bd6","x":-2479,"y":6619,"width":739,"height":841,"type":"group","label":"工作线程的阻塞与唤醒原理"},
		{"id":"f50220a4a657f41a","x":-3800,"y":4840,"width":641,"height":940,"type":"group","label":"线程池核心参数分析"},
		{"id":"634d408502b2d119","x":-3420,"y":6619,"width":714,"height":841,"type":"group","label":"工作线程复用原理"},
		{"id":"1b7af57954dbc048","type":"file","file":"resources/unsorted/Java多线程并发编程.md","x":-4620,"y":-720,"width":900,"height":140},
		{"id":"5f1b1e47b043229f","type":"text","text":"## 进程、线程和cpu核心数之间的关系\n1. 进程是程序运行资源分配的最小单位，这里的资源包括：cpu、内存空间、磁盘io等；进程分为系统进程和用户进程。\n2. 线程是CPU调度的最小单位，线程是进程的一个实体，任何一个线程都必须有一个线程，Java进程中必须有一个main线程\n3. cpu的核心（内核）与线程（逻辑处理器）：以Intel的cpu为例，核心数与线程数为1:2的关系，intel处理器引入了超线程技术；比如6核心12线程的i5处理器。","x":-4604,"y":-1120,"width":783,"height":300},
		{"id":"887a685f05a09491","type":"file","file":"notes/5_Linux Server/linux io模型.md","x":-2260,"y":-1260,"width":706,"height":880},
		{"id":"04e2954dcffff472","type":"text","text":"### 线程间通信（wait和notify/notifyAll）\n\n> [!NOTE]\n> 1. 线程间通信，是指两个不同的线程类（run方法是不同的），上述的多线程并发，指的是用同一个线程类创建的线程。线程间通信，可以用某个object对象作为锁，通过调用锁的wait（）和notify（）方法进行通信。\n> 2. wait和notify是Object类中的方法，Java中所有的对象都可以当做锁，调用锁的wait和notify方法来实现线程同步\n> 3. wait和notify方法必须在synchronized方法或代码块中调用，且调用的必须是该synchronized使用的锁的wait和notify方法，如果调用的是其他锁的wait和notify方法，会抛出IllegalMonitorStateException异常\n> 4. 调用wait方法会立即释放锁，调用notify方法不会立即释放锁，会在执行完synchronized方法后释放锁\n> 5. 在synchronized方法中调用Thread.sleep方法不会释放锁\n\n#### wait\n\n调用wait方法后会释放锁，wait方法后面的代码需要等到wait超时时间结束或被notify方法唤醒后，继续执行\n\n```Java\npublic class ThreadA {\n    public static void main(String[] args) {\n        ThreadB b = new ThreadB();\n        b.start();//主线程中启动另外一个线程\n        System.out.println(\"b is start....\");\n        //括号里的b是什么意思,应该很好理解吧\n        synchronized(b) {\n            try {\n                System.out.println(\"Waiting for b to complete...\");\n                b.wait();//这一句是什么意思，究竟谁等待?\n                System.out.println(\"ThreadB is Completed. Now back to main thread\");\n            }catch (InterruptedException e){}\n        }\n        System.out.println(\"Total is :\" + b.total);\n    }\n}\n\nclass ThreadB extends Thread {\n    int total;\n    public void run() {\n        synchronized(this) {\n            System.out.println(\"ThreadB is running..\");\n            for (int i=0; i<=100; i++ ) {\n                total += i;\n            }\n            System.out.println(\"total is \" + total);\n            notify();\n        }\n    }\n}\n```\n\n执行上面的代码可能有两种结果\n\n```\nb is start....\nThreadB is running..\ntotal is 5050\nWaiting for b to complete...\n程序陷入等到状态\n```\n\n这种结果是因为在main方法进入synchronized代码块之前，线程b已经执行完了，线程b中调用notify方法，但此时线程a(主线程)还没有去获取锁，notify没有作用，当主线程调用wait方法后，会一直等待。\n\n或\n\n```\nb is start....\nWaiting for b to complete...\nThreadB is running..\ntotal is 5050\nThreadB is Completed. Now back to main thread\nTotal is :5050\n程序结束\n```\n\n这种结果是因为主线程先进入synchronized代码块，调用wait方法，然后b线程获取到锁，调用notify方法，主线程被唤醒继续执行结束\n\n#### 使用wait/notify实现生产者消费者模式\n\n### sleep/yield/wait的区别\n\nsleep和wait\n\n- wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用\n- sleep必须捕获异常，而wait，notify和notifyAll不需要捕获异常\n- sleep不出让系统资源；wait是进入线程等待池等待，出让系统资源\n\nsleep和yield\n\n- sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会\n- 线程执行 sleep()方法后转入阻塞（blocked）状态，而执行 yield()方法后转入就绪（ready）状态\n- sleep()方法声明抛出 InterruptedException，而 yield()方法没有声明任何异常\n- sleep()方法比 yield()方法（跟操作系统 CPU 调度相关）具有更好的可移植性。\n\nyield和wait\n\n- wait让线程进入阻塞状态，阻塞时间结束，线程进入就绪状态\n- yield让线程进入就绪状态\n","x":-3560,"y":1004,"width":777,"height":602},
		{"id":"8b7da72abeebbe1a","type":"text","text":"## 线程通信相关方法比较\nObject类的方法：\nwait、notify、notifyAll\n\nThread类成员方法（在一个线程中，调用另一个线程的方法）：\nstart()\njoin()\ninterrupt()\n\nThread静态方法（改变线程自己的状体）：\nyield()\nsleep()\n\n\n| 方法                | 是否抛异常 | 是否释放锁 | 是否让出系统资源 | 必须在同步代码块中使用 |\n| ----------------- | ----- | ----- | -------- | ----------- |\n| object.wait()     | 是     | 立即释放  |          |             |\n| object.notify()   | 否     | 不立即释放 |          |             |\n| thread.join()     | 是     |       |          |             |\n| thread.interupt() | 否     |       |          |             |\n| Thread.sleep()    | 是     | 不释放   | 释放cpu    |             |\n| Thread.yield()    | 否     | 不释放   | 释放cpu    |             |\n#todo\n> [!NOTE] synchronized方法中调用yield方法，会不会释放锁\n> synchronized方法使用的锁对象\n\n\n> [!NOTE] 线程run方法中使用synchronized代码开，会有什么效果？\n> Contents\n\n","x":-3560,"y":1648,"width":777,"height":872},
		{"id":"7bfe6a44f2516e26","type":"text","text":"## Java线程中断\n\n\n### InterruptedException异常\n调用抛出InterruptedException异常方法\n1. 调用Thread类静态方法sleep()，等待指定时间\n2. 调用锁（Oject对象）的wait()方法，放弃已获取的锁，进入等待队列，等待被唤醒\n3. 调用Thread对象的join()方法，当前线程等待join线程执行完\n当前线程调用了这些方法后都会进入等待，如果在等待期间其他线程调用了当前线程的interrupt()方法\n当前线程就就会捕获到InterruptedException异常，结束等待，对中断异常进行处理。\n\n> [!tip] 方法抛出/捕获异常，后续方法还会继续运行吗？\n> 正确处理了异常，后续代码可以继续执行，所以线程被打断后可以继续执行\n\n\nThread.currentThread().interrupt();有什么作用\n\n```java\ntry {  \n    Thread.sleep(1000);  \n} catch (InterruptedException e) {  \n    Thread.currentThread().interrupt();  \n}\n```\n\n\n\n\n\n\n\n捕获到中断异常，不调用中断方法，会怎样？\n\n","x":-2663,"y":1019,"width":1143,"height":587},
		{"id":"012adf931a2abade","type":"text","text":"sleep（0）可以触发一次系统资源竞争\n与yield()类似","x":-2725,"y":1803,"width":765,"height":281},
		{"id":"60cdcdba2fb27c42","type":"text","text":"### Java线程间通信的方式\n1. wait/notify/notifyall(等待/通知机制)\n2. 共享内存volatile\n\n![[Pasted image 20240802093527.png]]\n\n> [!faq] 等待/通知机制线程调用的是谁的wait/notify方法？\n> wait/notify方法需要在synchronized代码块中调用，调用的是synchronized锁的wait/notify方法\n\n> [!NOTE] volatile通信\n> 通过volatile定义一个线程共享的标志变量，在某个线程更新标志变量时，其他线程可以立即看见\n","x":-4360,"y":1004,"width":601,"height":1033},
		{"id":"69275526b759f1ab","type":"file","file":"resources/unsorted/JVM线程状态流转图.svg","x":-4977,"y":1004,"width":451,"height":644},
		{"id":"a244d032e6e391cb","type":"text","text":"## Java线程创建方式\n\n### 继承Thread类\n\n```java\n/**\n * 使用单独的线程打印数字n以内的偶数\n */\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"main thread start!\");\n        SimpleThread simpleThread = new SimpleThread(100, \"simpleTread\");\n        simpleThread.start();\n        System.out.println(\"main thread exit!\");\n    }\n}\n\nclass SimpleThread extends Thread {\n    private int n;\n\n    public SimpleThread(int n) {\n        this.n = n;\n    }\n\n    public SimpleThread(int n, String name) {\n        super(name); // super()要放在最前面\n        this.n = n;\n    }\n\n    @Override\n    public void run() {\n        String currentThreadName = Thread.currentThread().getName();\n        System.out.println(currentThreadName + \" thread start!\");\n        if (n == 0) return;\n        for (int i = 0; i < n; i++) {\n            if (i % 2 == 0) System.out.println(currentThreadName + \" thread print \" + i);\n        }\n        System.out.println(currentThreadName + \" thread exit!\");\n    }\n}\n\n```\n\n\n\n### 实现Runnable或Callable接口\n\n```java\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.FutureTask;\n\npublic class Main {\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\n        System.out.println(\"main thread start!\");\n        SimpleRunnable simpleRunnable = new SimpleRunnable(100);\n        SimpleCallable simpleCallable = new SimpleCallable(100);\n        Thread simpleRunnableThread = new Thread(simpleRunnable, \"simpleRunnable\");\n        // FutureTask类实现RunnableTask接口，RunnableTask继承Runnable\n        FutureTask<Integer> simpleTask = new FutureTask<>(simpleCallable);\n        Thread simpleCallableThread = new Thread(simpleTask, \"simpleCallable\");\n        simpleRunnableThread.start();\n        simpleCallableThread.start();\n        // FutureTask的get方法会阻塞主线程\n        System.out.println(\"simpleCallable return \" + simpleTask.get());\n        System.out.println(\"main thread exit!\");\n    }\n}\n\nclass SimpleRunnable implements Runnable {\n    private int n;\n\n    public SimpleRunnable(int n) {\n        this.n = n;\n    }\n\n    @Override\n    public void run() {\n        String currentThreadName = Thread.currentThread().getName();\n        System.out.println(currentThreadName + \" thread start!\");\n        if (n == 0) return;\n        for (int i = 0; i < n; i++) {\n            if (i % 2 == 0) System.out.println(currentThreadName + \" thread print i = \" + i);\n        }\n        System.out.println(currentThreadName + \" thread exit!\");\n    }\n}\n\nclass SimpleCallable implements Callable<Integer> {\n    private int n;\n\n    public SimpleCallable(int n) {\n        this.n = n;\n    }\n\n    @Override\n    public Integer call() {\n        String currentThreadName = Thread.currentThread().getName();\n        System.out.println(currentThreadName + \" thread start!\");\n        if (n == 0) return 0;\n        int sum = 0;\n        for (int i = 0; i < n; i++) {\n            sum += i;\n            if (i % 2 == 0) System.out.println(currentThreadName + \" thread print sum = \" + sum);\n        }\n        System.out.println(currentThreadName + \" thread exit!\");\n        return sum;\n    }\n}\n```\n\n\n\n### 使用匿名内部类、lambda表达式创建线程\n\n```java\n// 创建匿名内部类可以new接口、抽象类、非抽象类\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.FutureTask;\n\npublic class Main {\n\n    public static void main(String[] args) throws Exception {\n        //使用 Callable和Future\n        FutureTask<Integer> ft = new FutureTask<>(new Callable<Integer>() {\n            @Override\n            public Integer call() throws Exception {\n                int sum = 0;\n                for (int i = 0; i < 1000; i++) {\n                    sum = sum + i;\n                }\n                Thread.sleep(2000);\n                System.out.println(\"sum = \" + sum);\n                return sum;\n            }\n        });\n        new Thread(ft, \"ft\").start();\n        //通过FutureTask中的get()方法获取返回值，get()方法会阻塞当前线程。\n        System.out.println(ft.get());\n        //new Runable接口\n        Thread tt = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(\"tt\");\n            }\n        },\"tt\");\n        //new Thread类，重写run方法\n        Thread dd = new Thread() {\n            @Override\n            public void run() {\n                try {\n                    Thread.sleep(1000);\n                    System.out.println(\"dd\");\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        };\n        dd.start();\n        System.out.println(\"end\");\n    }\n\n}\n```\n\n\n### 线程创建方式总结\n\n1. 启动一个线程，必须通过创建Thread类对象，并调用start方法，直接运行run方法不是多线程\n2. 实现Runnable和继承Thread的优缺点：继承Thread类不够灵活，因为Java只能单继承。","x":-5146,"y":-90,"width":620,"height":680},
		{"id":"66c91711165b95f4","type":"text","text":"\n## Java线程类-Thread\n\n### 构造方法\n\n```java\npublic Thread()\npublic Thread(Runnable target)\nThread(Runnable target, AccessControlContext acc)\npublic Thread(ThreadGroup group, Runnable target)\npublic Thread(String name)\npublic Thread(ThreadGroup group, String name)\npublic Thread(Runnable target, String name)\npublic Thread(ThreadGroup group, Runnable target, String name)\npublic Thread(ThreadGroup group, Runnable target, String name, long stackSize)\n```\n\n### 静态属性\n\n```java\nprivate static int threadInitNumber;\nprivate static synchronized int nextThreadNum() {\n    return threadInitNumber++;\n}\n\n/* For generating thread ID */\nprivate static long threadSeqNumber;\nprivate static synchronized long nextThreadID() {\n        return ++threadSeqNumber;\n    }\n\n/**\n     * The minimum priority that a thread can have.\n     */\npublic final static int MIN_PRIORITY = 1;\n\n/**\n     * The default priority that is assigned to a thread.\n     */\npublic final static int NORM_PRIORITY = 5;\n\n/**\n     * The maximum priority that a thread can have.\n     */\npublic final static int MAX_PRIORITY = 10;\n```\n\n### 实例属性\n\n```java\nprivate volatile String name;\nprivate int            priority;\nprivate Thread         threadQ;\nprivate long           eetop;\n\n/* Whether or not to single_step this thread. */\nprivate boolean     single_step;\n\n/* Whether or not the thread is a daemon thread. */\nprivate boolean     daemon = false;\n\n/* JVM state */\nprivate boolean     stillborn = false;\n\n/* What will be run. */\nprivate Runnable target;\n\n/* The group of this thread */\nprivate ThreadGroup group;\n\n/* The context ClassLoader for this thread */\nprivate ClassLoader contextClassLoader;\n\n/* The inherited AccessControlContext of this thread */\nprivate AccessControlContext inheritedAccessControlContext;\n\n/*\n     * The requested stack size for this thread, or 0 if the creator did\n     * not specify a stack size.  It is up to the VM to do whatever it\n     * likes with this number; some VMs will ignore it.\n     */\n    private long stackSize;\n\n    /*\n     * JVM-private state that persists after native thread termination.\n     */\n    private long nativeParkEventPointer;\n\n    /*\n     * Thread ID\n     */\n    private long tid;\n\nprivate volatile int threadStatus = 0;\n\nprivate volatile Interruptible blocker;\n    private final Object blockerLock = new Object();\n```\n\n### 静态native方法\n\n```java\npublic static native Thread currentThread();\npublic static native void yield();\npublic static native void sleep(long millis)\n    private native boolean isInterrupted(boolean ClearInterrupted);\npublic static native boolean holdsLock(Object obj)\n    private native static StackTraceElement[][] dumpThreads(Thread[] threads);\n    private native static Thread[] getThreads();\n```\n\n### 静态方法\n\n```java\npublic static void sleep(long millis, int nanos)\n    public static boolean interrupted()\n    \n    public static int activeCount()\n    public static int enumerate(Thread tarray[])\n    public static void dumpStack()\n    public static Map<Thread, StackTraceElement[]> getAllStackTraces()\n    public static void setDefaultUncaughtExceptionHandler(UncaughtExceptionHandler eh)\n    public static UncaughtExceptionHandler getDefaultUncaughtExceptionHandler()\n```\n\n### 非静态native方法\n\n```java\nprivate native void start0();\npublic final native boolean isAlive();\n@Deprecated\n    public native int countStackFrames();\n```\n\n### 实例方法\n\n```java\nvoid blockedOn(Interruptible b) {\n    synchronized (blockerLock) {\n        blocker = b;\n    }\n}\npublic synchronized void start()\n    \npublic void run() {\n    if (target != null) {\n        target.run();\n    }\n}\nprivate void exit()\n    @Deprecated\n    public final void stop()\n    public void interrupt()\n    \n    public boolean isInterrupted()\n    @Deprecated\n    public void destroy()\n       @Deprecated\n    public final void suspend()\n    @Deprecated\n    public final void resume()\n    \n    public final void setPriority(int newPriority)\n    public final int getPriority()\n    public final synchronized void setName(String name)\n    public final String getName() {\n        return name;\n    }\npublic final ThreadGroup getThreadGroup() {\n        return group;\n    }\npublic final synchronized void join(long millis)\n    public final void join()\n    public final void setDaemon(boolean on)\n    public final boolean isDaemon()\n    public final void checkAccess()\n    public void setContextClassLoader(ClassLoader cl)\n    public StackTraceElement[] getStackTrace()\n    public long getId()\n    public State getState()\n    public UncaughtExceptionHandler getUncaughtExceptionHandler()\n    public void setUncaughtExceptionHandler(UncaughtExceptionHandler eh)\n```\n\n### 静态代码块\n\n```java\nprivate static native void registerNatives();\nstatic {\n    registerNatives();\n}\n```\n\n\n### 常用方法\n\n实例方法\n\n- start\n\n- run\n\n- setName：一般在创建线程时设置线程名称，创建时没有设置，可以调用该方法设置，创建时已设置，使用该方法修改线程名\n\n- setPriority\n\n-  setDaemon守护线程可以在创建它的父线程结束后继续执行，直到进程退出。垃圾回收线程是守护线程\n\n-  join\n\n  - \n\n    ```java\n    // 在主线程中调用其他线程的join方法，主线程阻塞，直到被调用join方法的线程死亡（执行结束）\n    // 可以指定等待超时时间，0表示一直等待\n    public class Main {\n        public static void main(String[] args) throws InterruptedException, ExecutionException {\n            RunnableThread rt = new RunnableThread();\n            Thread thread = new Thread(rt);\n            thread.start();\n            // thread.join();\n            System.out.println(\"main thread end\");\n        }\n    }\n    ```\n\n    \n\n- interrupt线程处于阻塞状态，如`Thread.sleep、wait、IO阻塞`等情况时，调用interrupt方法后，sleep等方法将会抛出一个InterruptedException\n\n  - interrupted()是静态方法：内部实现是调用的当前线程的isInterrupted()，并且会重置当前线程的中断状态\n  - isInterrupted()是实例方法，是调用该方法的对象所表示的那个线程的isInterrupted()，不会重置当前线程的中断状态\n\n-  isAlive\n\n静态方法\n\n- sleep：阻塞线程，不会释放锁\n- yield：\n- holdsLock\n- currentThread()\n- dumpStack()\n\n","x":-2960,"y":180,"width":1040,"height":340},
		{"id":"ab69610d4ff08c9e","type":"text","text":"## Java线程生命周期\n\n[Java线程流转图](https://boardmix.cn/app/share/CAE.CLP6iA4gASoQImsK6udCM7DAsJHIwFNV3jAGQAE/jx6Sds)\n\n### 操作系统线程的五种状态\n\n- NEW\n- RUNNABLE\n- RUNNING\n- BLOCKED\n  - wati\n  - sleep\n  - io/lock\n- DEAD\n\n### Java线程的六种状态\n\n- NEW - 线程已创建，但未调用start()方法\n- RUNNABLE - 可运行状态（对应操作系统RUNNABLE和RUNNING状态），可能在等待操作系统资源，随时可能被CPU调度执行\n  - RUNNING运行在\n  - RUNNABLE（READY）就绪\n- BLOCKED - 暂时停止运行，直到进入就绪状态\n  - 等待阻塞 - 调用wait()\n  - 同步阻塞 - 获取同步锁失败\n  - 其他阻塞 - sleep/join/io\n- WAITING - 没有超时时间的等待\n- TIMED_WAITING - 有超时时间的等待\n- TERMINATED - 执行结束\n\n线程状态枚举类\n```java\npublic enum State {\n    /**\n     * Thread state for a thread which has not yet started.\n     */\n    NEW,\n\n    /**\n     * Thread state for a runnable thread.  A thread in the runnable\n     * state is executing in the Java virtual machine but it may\n     * be waiting for other resources from the operating system\n     * such as processor.\n     */\n    RUNNABLE,\n\n    /**\n     * Thread state for a thread blocked waiting for a monitor lock.\n     * A thread in the blocked state is waiting for a monitor lock\n     * to enter a synchronized block/method or\n     * reenter a synchronized block/method after calling\n     * {@link Object#wait() Object.wait}.\n     */\n    BLOCKED,\n\n    /**\n     * Thread state for a waiting thread.\n     * A thread is in the waiting state due to calling one of the\n     * following methods:\n     * <ul>\n     *   <li>{@link Object#wait() Object.wait} with no timeout</li>\n     *   <li>{@link #join() Thread.join} with no timeout</li>\n     *   <li>{@link LockSupport#park() LockSupport.park}</li>\n     * </ul>\n     *\n     * <p>A thread in the waiting state is waiting for another thread to\n     * perform a particular action.\n     *\n     * For example, a thread that has called <tt>Object.wait()</tt>\n     * on an object is waiting for another thread to call\n     * <tt>Object.notify()</tt> or <tt>Object.notifyAll()</tt> on\n     * that object. A thread that has called <tt>Thread.join()</tt>\n     * is waiting for a specified thread to terminate.\n     */\n    WAITING,\n\n    /**\n     * Thread state for a waiting thread with a specified waiting time.\n     * A thread is in the timed waiting state due to calling one of\n     * the following methods with a specified positive waiting time:\n     * <ul>\n     *   <li>{@link #sleep Thread.sleep}</li>\n     *   <li>{@link Object#wait(long) Object.wait} with timeout</li>\n     *   <li>{@link #join(long) Thread.join} with timeout</li>\n     *   <li>{@link LockSupport#parkNanos LockSupport.parkNanos}</li>\n     *   <li>{@link LockSupport#parkUntil LockSupport.parkUntil}</li>\n     * </ul>\n     */\n    TIMED_WAITING,\n\n    /**\n     * Thread state for a terminated thread.\n     * The thread has completed execution.\n     */\n    TERMINATED;\n}\n```\n\n\n#### 线程的同步队列和等待队列\n\n同步阻塞：进入Synchronized方法块(同步方法)时竞争锁的时候失败，则进入同步队列\n等待阻塞：比如线程调用了wait()方法，线程则进入等待队列，等待被唤醒再进入同步队列","x":-5770,"y":1004,"width":660,"height":1440},
		{"id":"48a9800a89545ed7","type":"text","text":"\n> [!NOTE] 并发编程的目的\n> 为了提高CPU资源利用率，让程序运行的更快\n\n并发编程并不是线程越多越好，cpu在各个线程之间切换需要进行上下文切换，频繁的上下文切换会占用更多的系统资源\n\n> [!NOTE] 并发编程如何减少上下文切换？\n> - 无锁并发编程 多线程竞争锁时，会引起上下文切换，所以多线程处理数据时，可以用一些方法来避免使用锁，如将数据的ID按照Hash算法取模分段，不同线程处理不同段的数据。\n> - CAS算法 Java的Atomic包使用CAS算法来更新数据，不需要加锁。\n> - 使用最少的线程来完成任务 避免不需要的线程。\n> - 协程 在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。\n\n\n> [!NOTE] 自旋是什么？\n> 在多线程编程中，当线程尝试获得某个锁时，如果该锁已经被其他线程占用，线程会一直循环检查该锁是否被释放，直到获取到该锁为止。这个循环等待的过程被称为自旋。自旋会消耗cpu资源，但线程状态不会改变，也就没有切换上下文的开销。\n","x":-5780,"y":2740,"width":680,"height":740},
		{"id":"0742165ddc5b640f","type":"text","text":"## 并发编程的三大特性\n\n**原子性**：一个或多个操作要么全部执行，要么都不执行，线程在执行原子性操作时不会被线程调度器中断；例如：a = 1给变量a赋值的操作就是原子操作，而a++就不是原子操作（a++包括多个操作，从主内存将变量a读取到线程内存中，累加，然后写回主内存中）\n\nJava中的原子操作：引用的赋值，java.concurrent.Atomic包下的类方法都是原子操作\n\n\n\n**可见性**：一个线程修改了共享变量，其他线程能立即看到。volatile变量在被线程修改后，会被立即更新到主内存，volatile变量读取直接从主内存读取，所以volatile变量具有可见性；使用synchronized和Lock也能保证变量的可见性，因为同一时刻只有一个线程能获取锁。\n\n\n\n**有序性**：程序的执行是按照代码的顺序，代码在编译后执行顺序不一定和代码顺序完全一样，编译器会对代码优化，在保证执行结果不变的情况下（在单线程环境下），进行指令重排。但是这种重排可能导致多线程的并发问题\n\n","x":-5060,"y":2740,"width":680,"height":740},
		{"id":"ec2088ffcc4c197e","type":"text","text":"## volatile修饰的变量\n\n\n> [!NOTE] volatile修饰变量在并发编程中的作用\n> 1. 保证变量可见性，通过直接读写主内存，不使用缓存\n> 2. 保证对变量操作的有序性，通过禁止指令重排\n\n\n> [!warning] volatile无法保证多线程环境下对变量操作的原子性\n> 在多线程环境下无法保证操作的原子性，比如自增操作，底层分为多步执行，执行过程中线程可能被中断；\n> volatile变量不适合复合操作（比如自增操作），如果在多线程环境下对共享变量进行复合操作可以考虑加锁或原子类，如果只进行原子操作（比如修改布尔变量，标识状态的变化）可以考虑volatile变量。\n\n\n\n> volatile关键字可以用来修饰字段（成员变量），告知Java程序任何对该变量的访问都要从共享内存（主内存）中获取，而对它的改变都必须同步刷新回共享内存。当一个变量被声明为volatile时，线程在写入变量时，不会把值缓存在寄存器或者高速缓存中（即本地内存），而是会把值刷新回主存，当要读取该共享变量时，线程则会先清空本地内存中的副本值，从主存中重新获取。\n\n1. volatile关键字为域变量的访问提供了一种免锁机制，  \n2. 使用volatile修饰域相当于告诉虚拟机该域可能会被其他线程更新，  \n3. 因此每次使用该域就要重新计算，而不是使用寄存器中的值  \n4. volatile不会提供任何原子操作，它也不能用来修饰final类型的变量\n\n\n\n\n\n\n\n","x":-3060,"y":2750,"width":920,"height":790},
		{"id":"f40ec1531f5661a8","type":"text","text":"java中每个对象都有一个内置的锁\n\n访问对象中同步的方法，需要先获取锁，获取不到就阻塞\n\n静态方法不属于对象，静态同步方法需要获取什么锁？","x":-2080,"y":2750,"width":465,"height":460},
		{"id":"86a50d3b2e9d4a84","type":"text","text":"## synchronized方法和代码块\n\n\n> [!NOTE] 使用synchronized注意事项\n> 1. synchronized方法的关键在锁，不同的锁有不同的功能，适应不同的场景，根据具体情况选择不同的锁\n> 2. 使用锁时要注意使用的要是同一个锁（同一个对象），在实现Runnable接口的类中编写同步方法或代码块，如果使用的是this锁，多个线程中出入的Runnable对象要是同一个（该Runnable对象只需要new一次），否则多个线程获取的不是同一个锁，就没法实现同步效果\n> 3. sychronized方法也可使用sychronized代码块的方式实现，将方法体全部包裹在代码块中；很情况下，一个方法中并不是所有的代码都需要同步，尽量使用同步代码块，缩小同步的代码范围也可以提升并发的性能\n> 4. 同步方法和同步代码块算是一种同步方式，被同步的代码同一时间只能有一个线程执行，保证了对公共资源操作的原子性；所以jvm实现的原子操作的代码可以不用同步，比如给一个int赋值；++不是原子操作，虽然只是一行代码也需要同步。\n\n### synchronized代码块demo\n使用同步代码块和同步方法处理多个线程售票同步问题\n\n```java\nimport java.util.Random;\nimport java.util.concurrent.*;\n\npublic class Main {\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\n        SimpleRunnable r = new SimpleRunnable(10);\n        Thread th1 = new Thread(r, \"thread1\");\n        Thread th2 = new Thread(r, \"thread2\");\n        th1.start();\n        th2.start();\n    }\n}\n\nclass SimpleRunnable implements Runnable {\n    private int n;\n\n    public SimpleRunnable(int n) {\n        this.n = n;\n    }\n\n    @Override\n    public void run() {\n        String currentThreadName = Thread.currentThread().getName();\n        System.out.println(currentThreadName + \" thread start!\");\n        while (n > 0) {\n            synchronized (this) {\n                if (n > 0) {\n                    System.out.println(currentThreadName + \"卖出第\" + n + \"张票\");\n                    n--;\n                } else {\n                    break;\n                }\n            }\n            try {\n                // 不要在同步代码中使用sleep，sleep不会释放锁\n                Thread.sleep(new Random().nextInt(2000));\n            } catch (InterruptedException e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        System.out.println(currentThreadName + \" thread exit!\");\n    }\n}\n```\n\n\n### 单独","x":-3880,"y":2771,"width":777,"height":629},
		{"id":"bd118334d8e713bf","type":"text","text":"总结：\n1. synchronized和Lock锁，都是给代码加锁\n2. 多线程中的非同步问题主要出现在对域的读写上，如果让域自身避免这个问题，则就不需要修改操作该域的方法。用final域，有锁保护的域和volatile域可以避免非同步的问题。","x":-2080,"y":3305,"width":465,"height":399},
		{"id":"72252a17854ac727","type":"text","text":"## 实现Lock接口的锁\n\nReentrantLock\n\n  ```java\n  Lock lock = new ReentrantLock();\n  lock.lock();//获取锁\n  //tryLock() 尝试获取锁，返回true/false\n  try{\n    \n  }catch(Exception e){\n    \n  }finally{\n    lock.unlock(); //释放\n  }\n  ```\n\n","x":-3880,"y":3450,"width":777,"height":160},
		{"id":"39883f7984501155","type":"text","text":"## 指令重排引发的并发问题\n\n\n> [!faq] Java中可能发生指令重排的操作（场景）有哪些？\n> \n\n\n\n### 懒汉单例模式在多线程环境中因指令重排引发的问题\n```java\npublic class DoubleCheckLock { \n\tprivate volatile static DoubleCheckLock instance; \n\tprivate DoubleCheckLock(){} \n\tpublic static DoubleCheckLock getInstance(){ \n\t\t//第一次检测 \n\t\tif (instance==null){ \n\t\t\t//同步 \n\t\t\tsynchronized (DoubleCheckLock.class){ \n\t\t\t\t//双重校验 \n\t\t\t\tif (instance == null){ \n\t\t\t\t\t//多线程环境下可能会出现问题的地方 \n\t\t\t\t\tinstance = new DoubleCheckLock(); \n\t\t\t\t} \n\t\t\t} \n\t\t} \n\t\treturn instance; \n\t} \n}\n```\n\n在new对象的时候分为三步\n```java\n//1.分配对象内存空间\nmemory = allocate();\n//2.初始化对象（填充数据）\ninstance(memory);\n//3.设置instance指向刚分配的内存地址，此时instance！=null\ninstance = memory;\n```\n\n由于步骤2和步骤3不存在数据依赖关系，而且无论重排前还是重排后程序的执行结果在单线程中并没有改变，因此这种重排优化是允许的。如果发生指令重排，重排结果如下：\n\n```java\n//1.分配对象内存空间\nmemory = allocate();\n//3.设置instance指向刚分配的内存地址，此时instance！=null\ninstance = memory;\n//2.初始化对象（填充数据）\ninstance(memory);\n```\n\n可以看到指令重排之后，instance指向分配好的内存地址放在了前面，而这段内存的初始化被排在了后面，在线程A初始化完成这段内存之前，线程B虽然进不去同步代码块，但是在同步代码块之前的判断就会发现instance不为空，此时线程B获得instance对象进行使用就可能发生错误。\n解决方案：使用volatile禁止instance变量被执行指令重排优化即可！！","x":-5780,"y":3520,"width":680,"height":840},
		{"id":"04a4e3556f36ca47","type":"text","text":"### CAS（compare and swap）\n\n> [!NOTE] CAS\n> CAS是一种无锁算法，即在不使用锁的情况下实现多线程之间变量的同步，所以也叫非阻塞同步（Non- blocking Synchronization）;CAS使用自旋操作实现无锁同步；CAS操作是CPU支持的原子指令；\n\n\n![[cas示意图.svg]]\n\n\n\n> [!NOTE] ABA问题\n> 假若一个变量V的值为A，线程1和线程2同时都读取到了这个变量的值A，此时线程1将V的值改为了B，然后又改回了A，期间线程2一直没有抢到CPU时间片。知道线程1将V的值改回A后线程2才得到执行。那么此时，线程2并不知道V的值曾经改变过。这个问题就被称为ABA问题。\n> 在CAS操作中，期望值E是变量V的某个时间点的快照，比较V和E的值就是为了判断在保存快照的时间点到当前时间点的时间间隔内，是否有其他线程对变量V进行修改，很显然可能会出现ABA问题\n> 解决方法：添加一个版本号，更次更新值同时也更新版本号即可。\n\n\n\n\n\n\n\n","x":-5060,"y":3520,"width":700,"height":860},
		{"id":"9a883cf6b37cd445","type":"text","text":"## 使用JUC包（java.util.concurrent）中的类\n\n### 原子类\n#todo\n> [!faq] 什么是原子类\n> 原子类提供的操作可以在多线程环境保证原子性\n\n\n> [!NOTE]- 原子类的分类\n> 1. 基本类型原子类\n> \t1. AtomicInteger\n> \t2. AtomicLong\n> \t3. AtomicBoolean\n> 2. 引用类型原子类\n> \t1. AtomicReference\n> \t2. AtomicStampedReference\n> \t3. AtomicMarkableReference\n> 3. 数组类型原子类\n> \t1. AtomicIntegerArray\n> \t2. AtomicLongArray\n> \t3. AtomicReferenceArray\n> 4. 对象属性原子类\n> \t1. AtomicIntegerFieldUpdater\n> \t2. AtomicLongFieldUpdater\n> \t3. AtomicReferenceFieldUpdater\n\n\n> [!NOTE] 原子类有哪些操作？\n> \n\n\n> [!NOTE] 原子类实现同步的原理\n> 原子类基于CAS原理实现无锁同步\n> Java支持CAS功能的类：sun.misc.Unsafe\n> 原子类中的变量使用volatile修饰，保证了可见性和有序性\n> 我们知道一个变量的自增操作不是原子操作，自增操作分为几个步骤\n> \t1. 读取变量当前值\n> \t2. 对当前值加一\n> \t3. 将结果赋值给变量\n> 原子类保证了自增操作的原子性，第一步读取变量V当前值作为CAS中的期望值E，在第三步赋值前将E与V比较，E记录的是V在第一步操作时的值，比较的目的是判断在执行第二步过程中，V是否被其他线程修改，如果没有被修改，就执行第三步。\n上述分析中也不难看出，就算V和E相等也无法确定中间V是否被其他线程修改过（也就是ABA问题），解决办法就是为变量添加版本号。\n\n\n> [!error] AtomicInteger无法避免ABA问题\n> AtomicInteger无法避免ABA问题，AtomicStampedReference可以用来解决ABA问题的。\n\n\n### 同步阻塞队列\n\n> [!NOTE] 同步阻塞队列实现类\n> 1. ArrayBlockingQueue\n> 2. LinkedBlockingQueue\n> 3. PriorityBlockingQueue\n> 4. DelayQueue\n> 5. SynchronousQueue\n\n#### 同步阻塞队列实现原理\n#todo\n\n\n\n\n\n### 其他\n- CountDownLatch\n- CyclicBarrier\n- Semaphore\n- ExChanger","x":-3040,"y":3610,"width":900,"height":750},
		{"id":"97959175d834cf0f","type":"text","text":"## 使用ThreadLocal实现同步","x":-3880,"y":3651,"width":777,"height":69},
		{"id":"adafc913fbd901ff","type":"text","text":"## 使用阻塞队列同步\n\n#### 阻塞队列实现生产者-消费者模式\n生产者线程\n```java\npublic class Producer extends Thread {\n    BlockingQueue<String> blockingQueue;\n    int id = 0;\n    public Producer(BlockingQueue<String> blockingQueue) {\n        this.blockingQueue = blockingQueue;\n    }\n\n    @Override\n    public void run() {\n        while (true) {\n            try {\n                String s = \"Item\" + id;\n                blockingQueue.put(s);\n                id++;\n                System.out.println(\"Producer produce: \" + s);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n消费者线程\n```java\npublic class Consumer extends Thread {\n    BlockingQueue<String> blockingQueue;\n    public Consumer(BlockingQueue<String> blockingQueue) {\n        this.blockingQueue = blockingQueue;\n    }\n\n    @Override\n    public void run() {\n        while (true) {\n            try {\n                String s = blockingQueue.take();\n                System.out.println(\"Consumer consume: \" + s);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n主线程\n```java\npublic class Main {\n    public static void main(String[] args) {\n        BlockingQueue<String> blockingQueue = new ArrayBlockingQueue<String>(5);\n        Thread producer = new Producer(blockingQueue);\n        Thread consumer = new Consumer(blockingQueue);\n\n        producer.start();\n        consumer.start();\n    }\n}\n```\n相比于wait/notify机制，使用BlockingQueue实现生产者消费者模式简单的很多。","x":-3880,"y":3800,"width":777,"height":560},
		{"id":"4c09fa37d2dd3377","type":"text","text":"## Java并发编程中的锁\n\n\n> [!NOTE] 什么是锁？\n> 锁在Java程序中就是一个对象\n> 锁分为对象锁和类锁，类锁是某个类的Class对象\n> 例如\n> - this指当前对象\n> - Object obj = new Object()，使用obj作为锁\n> - A.class指A类的class对象\n> 如果不指明锁，就使用默认锁，静态的同步方法默认使用当前类的Class对象作为锁\n\n\n\n### 锁的分类与功能\nJava中的锁可能同时满足不同的分类\n#todo\n此处详细分析各种锁的实现原理\n> [!NOTE] 偏向锁/轻量级锁/重量级锁\n> 一个对象被初始化后，还没有任何线程来获取它的锁时（延迟时间大约4秒，可设置，如果初始化4秒前就有线程来获取锁，就不是偏向），那么它就是可偏向的，当有第一个线程来访问它并尝试获取锁的时候，它就将这个线程记录下来，以后如果尝试获取锁的线程正是偏向锁的拥有者，就可以直接获得锁，开销很小，性能最好\n> 。。\n> 当锁原来是偏向锁的时候，被另一个线程访问，说明存在竞争，那么偏向锁就会升级为轻量级锁，线程会通过自旋的形式尝试获取锁，而不会陷入阻塞\n> 。。\n> 重量级锁是互斥锁，它是利用操作系统的同步机制实现的，所以开销相对比较大。当多个线程直接有实际竞争，且锁竞争时间长的时候，轻量级锁不能满足需求，锁就会膨胀为重量级锁。重量级锁会让其他申请却拿不到锁的线程进入阻塞状态\n> 。。\n> **偏向锁性能最好，可以避免执行 CAS 操作。而轻量级锁利用自旋和 CAS 避免了重量级锁带来的线程阻塞和唤醒，性能中等。重量级锁则会把获取不到锁的线程阻塞，性能最差**\n> 。。\n> **偏向锁**，不存在竞争的情况\n> **轻量级锁**，存在竞争，撤销偏向锁，使用自旋方式获取锁，不用切换上下文，使用CAS操作就可以\n> **重量级锁**，获取轻量级锁时，自旋次数过多，升级为重量级锁，获取不到锁会直接阻塞，发生上下文切换，性能最差\n\n\n> [!NOTE] 可重入锁/非可重入锁\n> 在已经获取了一个锁执行同步代码的过程中，又遇到同步代码的调用，而且需要获取的锁就是当前已经获取的锁。一个锁在不被释放的情况下，可以再次被以获取该锁的线程获取，称为可重入锁\n\n> [!NOTE] 共享锁/独占锁\n> 可以被多个线程同时获取的锁称为共享锁\n> 参考读锁/写锁\n\n> [!NOTE]\n> 悲观锁/乐观锁\n> 悲观锁是在获取资源前必须先获取锁\n> 乐观锁利用CAS理念，在不独占资源的情况下，完成对资源的修改\n\n> [!NOTE]\n> 自旋锁/非自旋锁\n> 获取锁时，如果无法立即获取到锁，就先自旋，反复去获取，而不是进入阻塞状态\n\n> [!NOTE]\n> 可中断锁/非可中断锁\n> 线程申请锁后，在获取到锁之前会阻塞，可中断锁是可以在获取到锁之前中断阻塞状态\n\n锁的状态\n","x":-5680,"y":4580,"width":600,"height":610},
		{"id":"2f1233f51911c115","type":"text","text":"### 死锁\n\n有两个锁对象A和B，E和F是两个线程类，E有嵌套的同步方法，先获取A锁，后获取B锁。F有嵌套的同步方法，先获取B锁\n\n后获取A锁。当E的线程获取了A锁，还没获取B锁，此时F的线程获取了B锁，就会形成死锁。\n\n死锁\n死锁就是两个或者两个以上的线程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象。\n\n**死锁产生的四个必要性：**\n\n- 互斥条件\n- 不可抢占条件\n- 请求和保持条件\n- 循环等待条件\n\n**避免死锁的几个常见方法：**\n\n- 避免获取同一个锁。\n- 避免一个线程在锁内同时占用多个资源，尽量保证每个锁只保持一个资源。\n- 尝试使用定时锁，使用tryLock(timeout)来代替使用内部锁机制。\n- 对于数据库锁，加锁和解锁必须在同一个数据库连接中，否则会出现解锁失败的问题。","x":-4814,"y":4580,"width":514,"height":610},
		{"id":"75c3f612b759b1ce","type":"text","text":"### synchronized与Lock\n\n[Java锁的同步队列和等待队列_Java部落格的博客-CSDN博客_锁等待队列](https://blog.csdn.net/lisheng5218/article/details/113741280)\n\nJava中的锁，可以分为Synchronized、AQS这两类。\n\nSynchronized是隐式锁，通过内部对象Monitor(监控器锁)实现，具体是由JVM中C++代码实现，`它有一个同步队列，一个等待队列`；\n\nAQS是显示锁，通过CAS、LockSurpport、CLH 双向链表实现，是由java代码实现，`它有一个同步队列，多个等待队列`。当使用Condition的时候，调用condition的await方法，将会使当前线程进入等待队，等待队列的唤醒是调用condition的signal方法。而AQS可以设置多个Condition，也就有了多个等待队列。\n\n\n\n- sychronized是关键字，Lock是接口\n\n- sychronized无法判断是否获取锁状态，Lock可以\n\n- sychronized自动释放锁，Lock需要在finally中使用unlock方法释放\n\n- sychronized会阻塞线程，Lock可以不用一直阻塞下去。\n\n- sychronized锁可重入，不可判断，非公平，Lock锁可重入，可判断，可公平\n\n- Lock锁适合大量同步代码的问题\n\n- ReentrantLock继承了Lock，是可重入锁\n\n- 为什么需要Lock锁：如果获取了synchronized锁的线程要等待IO等，其他的线程也会被阻塞。\n\n- 什么是可重入锁：比如线程类中有两个synchronized方法a和b，a中调用b，run方法中调用a\n  在线程执行run方法时就需要获取同一个锁两次，因为是同一个线程，同一个锁，所以可以多次\n  获取，不会死锁\n\n\n\n  \n\n[图解Java中那18 把锁 (qq.com)](https://mp.weixin.qq.com/s/l6ee7k0n7CCVFgBS4tI2kQ)\n\n\n","x":-5660,"y":5340,"width":780,"height":680},
		{"id":"fa7dd0a4b6383c4a","type":"text","text":"## Java并发编程出现的同步问题\n多线程同步，是指多个线程操作同一块内存时，必须按顺序执行，线程操作内存的过程还可以细分为更小的操作，同步就是为了保持线程操作内存整个过程的原子性。为了实现同步，就需要阻塞其他竞争资源的线程。\n\n> [!faq] 为什么需要线程同步？\n> 产生线程安全的原因是多个线程同时使用共享资源\n\n","x":-4620,"y":-520,"width":752,"height":88},
		{"id":"1a0ca72bb5e0e4f7","type":"text","text":"## Java线程运行原理\n\n创建一个Thread类对象，传入一个Runnable对象，保存到target\n\n```java\n/* What will be run. */  \nprivate Runnable target;\n\n```\nThread类本身是实现了Runnable接口的run方法的，只是简单的调用target的run方法\n```java\n@Override  \npublic void run() {  \n    if (target != null) {  \n        target.run();  \n    }  \n}\n```\n或者继承Thread类重写run方法","x":-3862,"y":67,"width":462,"height":653},
		{"id":"101e9191fdbaaf06","x":-3756,"y":4590,"width":476,"height":108,"type":"text","text":"java线程池其实就是一个通过阻塞队列实现的生产者-消费者模式案例\n- 生产者时提交任务的线程\n- 消费者时执行任务的工作线程\n分为三部分思考：\n1. 生产者正常提交任务\n\t1. 是否可以立即执行，\n\t2. 如果不能立即执行，是否可以将任务放在阻塞队列，\n2. 生产者无法提交任务（拒绝策略）\n3. 消费者执行任务\n\t1. 工作线程时如何复用\n4. 阻塞队列如何实现，工作线程的阻塞与唤醒\n5. 阻塞队列是否可以实现对生产者的阻塞和唤醒\n\n线程池是什么？\n线程池的优点？\n线程池如何使用？"},
		{"id":"df302c038d8faeaa","x":-3068,"y":4698,"width":261,"height":382,"type":"text","text":"线程池的创建\n任务对象的创建\n\n任务的提交或执行（submit execute）\n\n任务执行结果的获取\n\n线程池的销毁"},
		{"id":"afa6e3437e827f5a","x":-1701,"y":4775,"width":77,"height":400,"type":"file","file":"resources/unsorted/ScheduledThreadPoolExecutor类图.png"},
		{"id":"920c57a679a7fb4f","type":"text","text":"### 使用线程池\n\n#### Java线程池\n\n线程池核心参数：\n\n- 核心线程数 - corePoolSize\n- 最大线程数 - maximumPoolSize\n- 空闲线程存活时间 - keepAliveTime\n- 存活时间单位 - unit\n- 阻塞队列 - workQueue\n- 任务拒绝策略（线程池饱和策略）- handler\n\n线程池接收任务的顺序：线程池初始状态，没有可用线程，此时接收到新任务，就创建线程处理任务，如果线程数达到核心线程数，会将新接收的任务放到阻塞队列，如果队列已满，就继续创建线程，直到线程数达到最大线程数，此时无法接收更多的任务，拒绝任务。\n\nJava提供Executors类和ThreadPoolExecutor类来创建线程池，实际项目不推荐使用Executors，用在demo中比较合适，阿里巴巴的编码规范指出使用Executors创建线程池的弊端：\n\n- FixedThreadPool 和 SingleThreadPool：允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。\n- CachedThreadPool：允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。\n\n##### Executors创建线程池\n\nExecutors是一个静态工厂，提供如下创建线程池的静态方法\n\n- `public static ExecutorService newFixedThreadPool(int nThreads)` 一种线程数量固定的线程池，当线程处于空闲状态时，他们并不会被回收，除非线程池被关闭。当所有的线程都处于活动状态时，新的任务都会处于等待状态，直到有线程空闲出来。\n- `public static ExecutorService newSingleThreadExecutor()` 创建单个线程。它适用于需要保证顺序地执行各个任务;并且在任意时间点，不会有多个线程是活动的应用场景。\n- `public static ExecutorService newCachedThreadPool()` 创建一个根据需要创建新线程的线程池，但在可用时将重新使用以前构造的线程, 如果没有可用的线程，将创建一个新的线程并将其添加到该池中。 未使用六十秒的线程将被终止并从缓存中删除。\n- `public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)` 创建一个线程池，可以调度命令在给定的延迟之后运行，或定期执行, 支持执行定时性或周期性任务。\n- `public static ExecutorService newWorkStealingPool(int parallelism)` 创建一个维护足够的线程以支持给定的并行级别的线程池，并且可以使用多个队列来减少争用。 ( jdk1.8版本新增的方法 )\n\n```java\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.*;\n\npublic class Main {\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\n        System.out.println(\"main thread start!\");\n        SimpleRunnable simpleRunnable = new SimpleRunnable(100);\n        SimpleCallable simpleCallable = new SimpleCallable(100);\n        // 创建线程池\n        ExecutorService fixedThreadPool = Executors.newFixedThreadPool(3);\n        List<Future<Integer>> futureList = new ArrayList<>();\n        for (int i = 0; i < 5; i++) {\n            fixedThreadPool.execute(simpleRunnable);\n            Future<Integer> callableResult  = fixedThreadPool.submit(simpleCallable);\n            futureList.add(callableResult);\n        }\n\n        System.out.println(\"main thread exit!\");\n    }\n}\n\nclass SimpleRunnable implements Runnable {\n    private int n;\n\n    public SimpleRunnable(int n) {\n        this.n = n;\n    }\n\n    @Override\n    public void run() {\n        String currentThreadName = Thread.currentThread().getName();\n        System.out.println(currentThreadName + \" thread start!\");\n        if (n == 0) return;\n        for (int i = 0; i < n; i++) {\n            if (i % 2 == 0) System.out.println(currentThreadName + \" thread print i = \" + i);\n        }\n        System.out.println(currentThreadName + \" thread exit!\");\n    }\n}\n\nclass SimpleCallable implements Callable<Integer> {\n    private int n;\n\n    public SimpleCallable(int n) {\n        this.n = n;\n    }\n\n    @Override\n    public Integer call() {\n        String currentThreadName = Thread.currentThread().getName();\n        System.out.println(currentThreadName + \" thread start!\");\n        if (n == 0) return 0;\n        int sum = 0;\n        for (int i = 0; i < n; i++) {\n            sum += i;\n            if (i % 2 == 0) System.out.println(currentThreadName + \" thread print sum = \" + sum);\n        }\n        System.out.println(currentThreadName + \" thread exit!\");\n        return sum;\n    }\n}\n```\n\n\n\n##### ThreadPoolExecutor创建线程池\n\nThreadPoolExecutor实现了ExecutorService接口\n\n提交Runnable和Callable任务使用的方法不同\n\n同一线程池可以接收不同类型的任务\n\n\n\n```java\npublic class RunnableThread implements Runnable {\n    @Override\n    public void run() {\n        try {\n            System.out.println(\"runnable task executing: \" + Thread.currentThread().getName());\n            Thread.sleep(1000);\n            System.out.println(\"runnable task finished: \" + Thread.currentThread().getName());\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\npublic class CallableThread implements Callable<String> {\n    @Override\n    public String call() throws Exception {\n        System.out.println(\"callable task submitted: \" + Thread.currentThread().getName());\n        Thread.sleep(1000);\n        System.out.println(\"callable task finished: \" + Thread.currentThread().getName());\n        return \"ok\";\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) throws InterruptedException, ExecutionException {\n        RunnableThread rt = new RunnableThread();\n        CallableThread ct = new CallableThread();\n        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(\n          3,6,2000, TimeUnit.MILLISECONDS,new LinkedBlockingQueue<>(10),\n                Executors.defaultThreadFactory(), new ThreadPoolExecutor.DiscardPolicy()\n        );\n        Random random = new Random();\n        List<Future<String>> futureList = new ArrayList<>();\n        for (int i = 0; i < 50; i++) {\n            int r = random.nextInt(1000);\n            Thread.sleep(100);\n            if (r > 500) {\n                threadPoolExecutor.execute(rt);\n            } else {\n                Future<String> future = threadPoolExecutor.submit(ct);\n                futureList.add(future);\n            }\n        }\n        \n        for (Future<String> future : futureList) {\n            while (true) {\n                if (future.isDone() && !future.isCancelled()) {\n                    System.out.println(future.get());\n                    break;\n                } else {\n                    Thread.sleep(100);\n                }\n            }\n        }\n    }\n\n}\n```\n\n\n\n#### 线程池实现原理\n\n​\t线程池，自己实现线程池，如何在线程执行完后回收线程\n\n问：线程池是如何在任务结束后回收线程而不让线程结束\n\n在run方法中使用while循环从任务队列获取新任务\n\n问：如何优雅结束线程池，拒绝接收新任务，等待未完成任务执行完\n\n问：为什么主线程结束，而线程池还在运行？\n\n答：在 **ThreadPoolExecutor#runWorker** 方法中有一个while循环，这个while循环的条件是：\n\n```java\nwhile (task != null || (task = getTask()) != null)\n```\n\n此条件总是为true","x":-2241,"y":4654,"width":540,"height":740},
		{"id":"6a19402fba776f52","x":-2720,"y":4624,"width":440,"height":770,"type":"text","text":"```java\nimport java.util.Random;  \nimport java.util.concurrent.*;  \n  \n  \npublic class Demo {  \n  \n    public static void main(String[] args) {  \n\t\t/**  \n\t\t * 拒绝策略：默认策略是AbortPolicy，拒绝任务并抛出异常  \n\t\t * CallerRunsPolicy是在任务提交线程中直接运行任务的run方法  \n\t\t */\n        ThreadPoolExecutor executor = new ThreadPoolExecutor(2, 5, 60, TimeUnit.SECONDS,  \n                new ArrayBlockingQueue<Runnable>(10),  \n                Executors.defaultThreadFactory(),  \n                new ThreadPoolExecutor.CallerRunsPolicy()  \n        );  \n        // 使用Executors类快速创建线程池  \n        // ExecutorService executorService = Executors.newFixedThreadPool(10);  \n        // 使用lambda表达式创建task  \n        Runnable runnableTask = () -> {  \n            try {  \n                Thread.sleep(1000);  \n            } catch (InterruptedException e) {  \n                Thread.currentThread().interrupt();  \n            }  \n            System.out.println(\"runnableTask executed in thread: \" + Thread.currentThread().getName());  \n        };  \n  \n        Callable<Integer> callableTask = () -> {  \n            try {  \n                Thread.sleep(1000);  \n            } catch (InterruptedException e) {  \n                Thread.currentThread().interrupt();  \n            }  \n            System.out.println(\"callableTask executed in thread: \" + Thread.currentThread().getName());  \n            return new Random(1000).nextInt(10);  \n        };  \n  \n        // 执行任务  \n        executor.execute(runnableTask);  \n        // 提交任务，获取结果  \n        Future<Integer> futureResult = executor.submit(callableTask);  \n        try {  \n            Integer result = futureResult.get();  \n            System.out.println(result);  \n        } catch (InterruptedException | ExecutionException e) {  \n            throw new RuntimeException(e);  \n        }  \n  \n        // 关闭线程池  \n        executor.shutdown();  \n        try {  \n            while (!executor.awaitTermination(2, TimeUnit.SECONDS)) {  \n                System.out.println(\"线程池还未关闭！\");  \n                System.out.println(\"Active: \" + executor.getActiveCount());  \n            }  \n        } catch (InterruptedException e) {  \n            Thread.currentThread().interrupt();  \n        }  \n        System.out.println(\"线程池已关闭！\");  \n    }  \n}\n\n```"},
		{"id":"b16f5bd3b49fd6d7","x":-2416,"y":6660,"width":401,"height":304,"type":"text","text":"\n> [!faq] 当工作线程，从工作队列取任务时，没有任务，会被阻塞，当新任务到来时，如何让工作线程继续运行？多个线程都在等待任务，新任务到来时，分配给谁？\n> \n"},
		{"id":"b585c093cf6b12e6","x":-2416,"y":7020,"width":353,"height":401,"type":"text","text":"从阻塞队列获取元素的方法\ntake(获取不到会阻塞)\npoll（获取不到返回null）\n\n take方法中又使用了Condition接口的await方法\n\n阻塞队列底层就是使用\nCondition接口的await/signal/signalAll实现的阻塞与唤醒"},
		{"id":"d881112a89614019","type":"text","text":"线程池中的工作线程\n\n工作线程在run方法中做了一个循环，不停的从任务队列获取任务对象（Runnable对象），获取不到任务对象就挂起等待新任务，获取到任务就调用任务对象的run方法","x":-3366,"y":6660,"width":545,"height":235},
		{"id":"6d3942d6bc2fd53e","x":-3366,"y":6978,"width":444,"height":360,"type":"text","text":"工作线程循环从工作队列中取任务的代码在哪里？\n线程复用的实现：\n循环从阻塞队列获取任务，获取不到就阻塞\n\n```java\nfinal void runWorker(Worker w) { Runnable task = w.firstTask; while (task != null || (task = getTask()) != null) { try { task.run(); } finally { task = null; } } }\n```\n\n从阻塞队列获取任务\n```java\nRunnable r = timed ? workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : workQueue.take();\n```"},
		{"id":"fc4d181fe73e4d43","type":"text","text":"线程池中的任务对象\n\n提交给线程池的任务，是一个Runnable对象\n假设MyTask类实现了Runnable接口，同一个MyTask对象提交十次和提交十个MyTask对象的区别；\n\n如果每个任务都有单独的数据，就使用十个不同的对象，如果没有就使用同一个对象\n\n每个任务都使用独立的对象，会增加内存消耗。可以将任务要使用的数据放到一个集合或队列里，任务执行的时候从队列取，这种方式需要考虑多线程取数据的同步，同步必然导致性能下降。\n所以根据实际情况选择不同的方式","x":-3359,"y":5906,"width":399,"height":574},
		{"id":"cdd59596272bc9d3","x":-2839,"y":5906,"width":825,"height":280,"type":"text","text":"\n> [!NOTE]  executor.submit(task)和executor.execute(task)的区别？\n> - 接收参数不同，submit接收runnable和callable，execute只接收runnable\n> - 返回值不同，submit返回FutureTask，用来获取结果\n\n## ThreadPoolExecutor的submit()方法\nThreadPoolExecutor中的submit方法是继承自AbstractEExecutorService抽象类\n\n```java\n/**  \n * @throws RejectedExecutionException {@inheritDoc}  \n * @throws NullPointerException       {@inheritDoc}  \n */public Future<?> submit(Runnable task) {  \n    if (task == null) throw new NullPointerException();  \n    RunnableFuture<Void> ftask = newTaskFor(task, null);  \n    execute(ftask);  \n    return ftask;  \n}  \n  \n/**  \n * @throws RejectedExecutionException {@inheritDoc}  \n * @throws NullPointerException       {@inheritDoc}  \n */public <T> Future<T> submit(Runnable task, T result) {  \n    if (task == null) throw new NullPointerException();  \n    RunnableFuture<T> ftask = newTaskFor(task, result);  \n    execute(ftask);  \n    return ftask;  \n}  \n  \n/**  \n * @throws RejectedExecutionException {@inheritDoc}  \n * @throws NullPointerException       {@inheritDoc}  \n */public <T> Future<T> submit(Callable<T> task) {  \n    if (task == null) throw new NullPointerException();  \n    RunnableFuture<T> ftask = newTaskFor(task);  \n    execute(ftask);  \n    return ftask;  \n}\n```\n由源码可以看出，submit()方法就是将【Runnable对象和结果对象】或【Callable对象】封装成RunnableFuture对象（FutureTask），然后传递给execute()方法执行;\n\n> [!NOTE] submit方法，传入Runnable对象，为何能获取返回值的？\n> 1. submit()接受Runnable和Callable类型参数，统一将参数封装成RunnableFuture(FutureTask)，调用execute(FutureTask)执行；最后返回FutureTask\n> \n> 2. 因为execute()只接受Runnable类型参数，execute中只能调用Runnable的run方法，FutureTask不得不在run方法中对Callable对象的call方法进行转换。\n> \n> 3. FutureTask又实现了Future接口，可以通过Future接口的get方法获取返回值\n> \n> 4. 调用submit(Runnable run, Object result)的时候，该怎在run方法中获取到result，并对其修改\n>    将result作为Runnable对象的属性。\n\n## ThreadPoolExecutor的execute()方法\nsubmit()方法只是对传入的Runnable和Callable对象进行统一封装，然后调用execute()方法执行，execute()方法不是简单的调用任务中的run方法，还有处理执行策略的代码\n```java\n public void execute(Runnable command) {  \n    if (command == null)  \n        throw new NullPointerException();  \n  int c = ctl.get();  \n    if (workerCountOf(c) < corePoolSize) {  \n        if (addWorker(command, true))  \n            return;  \n        c = ctl.get();  \n    }  \n    if (isRunning(c) && workQueue.offer(command)) {  \n        int recheck = ctl.get();  \n        if (! isRunning(recheck) && remove(command))  \n            reject(command);  \n        else if (workerCountOf(recheck) == 0)  \n            addWorker(null, false);  \n    }  \n    else if (!addWorker(command, false))  \n        reject(command);  \n}\n```\n\n\n\n"},
		{"id":"d58a3272b1679dfc","x":-2799,"y":5440,"width":391,"height":312,"type":"text","text":"## 线程池关闭\n线程池如果不调用关闭的方法，主线程结束后，线程池依然在运行。因为线程池中的工作线程还在阻塞。注意如果只是初始化线程池，没有提价任务，主线程结束，线程池不会继续运行，因为线程池是在提交第一个任务时才创建工作线程。"},
		{"id":"a1dc453513126ee6","x":-3756,"y":4889,"width":250,"height":331,"type":"text","text":"核心线程数\n和最大线程数该如何设置比较好\n\n最大空闲时间根据什么设置\n\n"},
		{"id":"5e901488627770a5","x":-3480,"y":4889,"width":250,"height":296,"type":"text","text":"阻塞队列可选哪些\n\n该如何选取"},
		{"id":"faa61e2729c185ef","x":-3756,"y":5280,"width":305,"height":400,"type":"file","file":"resources/unsorted/Pasted image 20240803181340.png"},
		{"id":"c4083a525ebdf336","x":-3420,"y":5220,"width":250,"height":260,"type":"text","text":"什么情况下使用自定义线程工厂，\n通过自定义线程工厂，自定义线程名称，打印日志\n"},
		{"id":"3acb4a2f5d3193d3","x":-3420,"y":5500,"width":250,"height":220,"type":"text","text":"拒绝策略该如何选\n- AbortPolicy：拒绝并抛出异常。\n- CallerRunsPolicy：使用当前调用的线程来执行此任务。\n- DiscardOldestPolicy：抛弃队列头部（最旧）的一个任务，并执行当前任务。\n- DiscardPolicy：忽略并抛弃当前任务。"}
	],
	"edges":[]
}