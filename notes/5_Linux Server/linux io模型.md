## Linux IO模型
read/write是通用的文件描述符操作；recv/send通常应用于TCP；recvfrom/sendto通常应用于UDP；
1. read/write
2. recv/send
3. recvfrom/sendto
	1. 在无连接的数据报socket方式下（UDP），需要指明目的地址
	2. recvfrom/sendto调用都是阻塞的

一个输入操作包含两个阶段：
1. 等待数据准备好（将数据从网络读取到内核缓冲区）
2. 从内核向用户进程复制数据

![[Pasted image 20240801102543.png]]


> [!faq] 读取本地文件需要先复制到内核缓冲区吗？从数据库读取呢？
> 磁盘文件的IO比较特殊，内核采用缓冲区cache加速磁盘IO请求。实际上在磁盘IO中，等待阶段是不存在的，因为磁盘文件并不像网络IO那样，需要等待远程传输数据。


### 1.阻塞IO模型

![[Pasted image 20240801103008.png]]

> [!NOTE] 阻塞模型结合多线程或多进程
> 在服务器端使用阻塞I/O模型时结合**多进程/多线程**技术。让每一个连接都拥有独立的进程/线程，任何一个连接的阻塞都不会影响到其他连接。（选择多进程还是多线程并无统一标准，因为进程的开销远大于线程，所以在连接数较大的情况下推荐使用多线程。而进程相较于线程具有更高的安全性，所以如果单个服务执行体需要消耗较多的CPU资源，如需要进行大规模或长时间的数据运算或文件访问推荐使用多进程）。
> 当连接数规模继续增大，无论使用多线程还是多进程都会严重占据系统资源，降低系统对外界的响应效率，线程或者进程本身也更容易陷入假死。此时可以采用“线程池”或“连接池”来降低创建和销毁进程/线程的频率，减少系统开销。


### 2.非阻塞IO模型

![[Pasted image 20240801105747.png]]

Linux通过设定O_NONBLOCK标志，以非阻塞方式打开文件
周期性检查（轮询）某个文件描述符是否可执行I/O操作
可以在轮询的间隙处理其他任务，在一个紧凑的循环中做轮询就是在**浪费CPU时间**，因为多数时间调用会立即出错并返回。


### 3.多路复用IO模型

![[Pasted image 20240801110159.png]]



I/O多路复用（也叫做事件驱动I/O）通过系统调用`select()`、`poll()`、或者`epoll()`实现进程同时检查多个文件描述符，以找出其中任何一个是否可执行I/O操作。通过上图可以看出I/O多路复用与阻塞I/O模型差别并不大，事实上还要差一些，因为这里使用了两个系统调用而阻塞I/O只是用了一个系统调用。但是I/O多路复用的优势是其可以同时处理多个连接。因此如果处理的连接数不是特别多的情况下使用I/O多路复用模型的web server不一定比使用多线程技术的阻塞I/O模型好。



### 4.信号驱动IO模型
![[Pasted image 20240801112844.png]]

准备数据阶段不阻塞

### 5.异步IO模型
![[Pasted image 20240801113403.png]]

与信号驱动式I/O模型的区别  
信号驱动式I/O是由内核告诉我们何时可以启动一个I/O操作，而异步I/O模型则是由内核通知我们I/O操作何时完成。


> [!summary] 总结
> 阻塞IO和非阻塞IO 都是同步的，非阻塞的意义是可以在等待IO的时候处理其他逻辑，
> io多路复用也是同步阻塞的，用更复杂的编程，使用一个线程管理多个连接
> 信号驱动io是既有同步阻塞也有异步非阻塞
> 异步io则是完全异步非阻塞


> **阻塞IO和非阻塞IO的区别在于第一步发起IO请求是否会被阻塞**

| io模型   | 同步/异步 | 阻塞/非阻塞                     |
| ------ | ----- | -------------------------- |
| 阻塞IO   | 同步    | IO整个过程阻塞                   |
| 非阻塞IO  | 同步    | 轮询阶段非阻塞，数据拷贝阶段阻塞           |
| 多路复用IO | 同步    | IO整个过程阻塞                   |
| 信号驱动IO | 同步    | 发起两次IO相关的系统调用，第一次非阻塞，第二次阻塞 |
| 异步IO   | 异步    | IO整个过程非阻塞                  |
**可见如果整个IO过程都没有阻塞，就是异步IO**

**同步IO是指当前过程（线程/进程）中的操作和IO操作要按顺序执行，按顺序执行就必须阻塞**

**将进程/线程中的IO操作和其他操视为CPU资源的竞争者，同步就是按顺序获取CPU资源（也就是执行代码），在IO操作进行时阻塞当前进程/线程，就是阻塞IO操作的后续操作，也就是阻塞资源的竞争者。**

### select、poll、epoll的实现细节

> [!todo] todo
> Contents



### 事件驱动、信号驱动、回调

IO多路复用是事件驱动的一种
信号驱动时事件驱动的一种

>同步回调和异步回调
首先，理解几个概念:
1.回调可以是同步也可以是异步
2.同步可以是单线程也可以是多线程
   异步必须是多线程或多进程（每个进程可以是单线程） ==> 换句话说，异步必须依靠多线程或多进程才能完成
**同步回调**：把函数b传递给函数a。执行a的时候，回调了b，a要一直等到b执行完才能继续执行；
**异步回调**：把函数b传递给函数a。执行a的时候，回调了b，然后a就继续往后执行，b独自执行。

**类比异步IO，异步回调，就是在整个回调过程中都没有阻塞**