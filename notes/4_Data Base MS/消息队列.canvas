{
	"nodes":[
		{"id":"8203cd093bc23705","type":"text","text":"连接和通道\n连接指物理连接\n一个连接可以生成多个通道\n通道是依赖连接而存在的\n连接关闭，通道也关闭\n连接可以保持\n连接的创建比较消耗资源，所以连接不宜频繁创建和销毁\n","x":536,"y":520,"width":304,"height":320},
		{"id":"9569926132f1f3d2","type":"file","file":"resources/unsorted/屏幕截图_9-8-2024_04510_www.bilibili.com.jpeg","x":-720,"y":-620,"width":400,"height":223},
		{"id":"5ad45f1090d0dc4f","type":"text","text":"消息队列的使用场景","x":-260,"y":-620,"width":276,"height":89},
		{"id":"2a09e15946566b04","type":"text","text":"redis实现简单的消息队列\n","x":-286,"y":-489,"width":546,"height":92},
		{"id":"db2d70bc638d2b8d","type":"text","text":"## 基本消息队列代码\n### 原始写法\n\npublisher\n```java\nConnectionFactory factory = new ConnectionFactory();\nfactory.setHost()\nfactory.setPort();\n\nConnection conn = foctory.newConnecton();\nChannel channel = conn.createChannel();\n\nString queueName = \"testQueue\"\nchannel.queueDeclare(queueName,false,false,false);\n\nchannel.basicPublish();\nchannel.close();\nconnection.close();\n\n```\nconsumer\n```java\nConnectionFactory factory = new ConnectionFactory();\nfactory.setHost()\nfactory.setPort();\n\nConnection conn = foctory.newConnecton();\nChannel channel = conn.createChannel();\n\nString queueName = \"testQueue\"\nchannel.queueDeclare(queueName,false,false,false);\n\nchannel.basicConsume(..., new DefaultConsumer(channel));\nchannel.close();\nconnection.close();\n```\n\n### springboot中写法","x":-750,"y":-303,"width":766,"height":1103},
		{"id":"3b50e6df9ed3f237","type":"file","file":"notes/4_Data Base MS/card/RabbitMQ.md","x":80,"y":-303,"width":786,"height":640},
		{"id":"b66a83beb79cd577","type":"text","text":"## springboot集成rabbitmq\n\n### 基础配置\n\n1. 引入starter依赖\n2. 配置rabbitmq的相关参数\n\n### 基本消息队列\n\n```java\n@SpringBootTest  \npublic class SpringAmqpTest {  \n    @Autowired  \n    private RabbitTemplate rabbitTemplate;  \n    @Test  \n    public void testBasicPublish() {  \n        rabbitTemplate.convertAndSend(\"test.queue\", \"Hello Worlgd\");  \n    }  \n  \n}\n```\n\n```java\n@Component  \npublic class SimpleRabbitListener {  \n    @RabbitListener(queues = \"test.queue\")  \n    public void listen(String msg) {  \n        System.out.println(\"msg = \" + msg);  \n    }  \n  \n}\n```\n\n\n> [!faq] 疑问\n> 为什么redisTemplate发送的消息会在redisTemplate关闭后自动消失？\n> redisTemplate能不能消费消息？\n\n\n### 工作消息队列\n一个生产者，多个消费者，一个消息只发送给一个消费者。本质是一个基本消息队列，可以提高消费者吞吐量，避免消息堆积在队列里。\n\n> [!faq] 如果队列已满，新来的消息如何处理？\n> Contents\n\n默认情况下，消息队列里的消息是平均分配给多个消费者的，不论消费者处理消息的速度。\n是用prefetch: 1配置，让消费者一次读取一个消息，处理完再取\n\n\n### 发布订阅模式\n\n一个消息发送到多个消费者，通过交换机（exchange）实现\n\n![[屏幕截图_9-8-2024_11811_www.bilibili.com.jpeg]]\n\nexchange只转发消息，不存储消息，转发失败，消息丢失\nexchange转发消息的策略有：\n1. 广播（Fanout）\n2. 路由（Direct）\n3. 话题（Topic）\n#### 广播模式\n每个绑定的队列都发送一份消息\n\n#### 路由模式\n![[屏幕截图_9-8-2024_114733_www.bilibili.com.jpeg]]\n通过给消息绑定key，通道绑定key，实现精准的路由\n消息发送代码\n![[屏幕截图_9-8-2024_115730_www.bilibili.com.jpeg]]\n消息接收代码\n![[屏幕截图_9-8-2024_115443_www.bilibili.com.jpeg]]\n\n\n#### 话题模式\n话题模式和路由模式的区别就是：key\n\n![[屏幕截图_9-8-2024_12444_www.bilibili.com.jpeg]]","x":-720,"y":960,"width":791,"height":1084},
		{"id":"429f567e2d45f0fc","type":"text","text":"### 消息转换\n发送消息时可以发送任意Java对象，默认使用的消息转换器时，Java序列化器\n\n配置json转换器\n使用org.springframework.amqp包下的的json转换器即可\n\n![[屏幕截图_9-8-2024_121213_www.bilibili.com.jpeg]]","x":-720,"y":2080,"width":396,"height":300}
	],
	"edges":[]
}